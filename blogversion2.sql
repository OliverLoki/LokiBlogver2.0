/*
 Navicat Premium Data Transfer

 Source Server         : wangzhe
 Source Server Type    : MySQL
 Source Server Version : 80023
 Source Host           : localhost:3306
 Source Schema         : blogversion2

 Target Server Type    : MySQL
 Target Server Version : 80023
 File Encoding         : 65001

 Date: 06/12/2021 13:16:27
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for album
-- ----------------------------
DROP TABLE IF EXISTS `album`;
CREATE TABLE `album`  (
  `pic_id` bigint NOT NULL,
  `pic_auth` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `pic_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `pic_email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`pic_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of album
-- ----------------------------

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `blog_id` bigint NOT NULL AUTO_INCREMENT,
  `blog_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `blog_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `blog_commentcount` int NULL DEFAULT 0,
  `blog_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `blog_emojicount` int NULL DEFAULT NULL,
  `type_id` int NULL DEFAULT NULL,
  `user_id` int NOT NULL,
  `gmt_create` datetime NULL DEFAULT NULL,
  `gmt_modified` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (1, 'JavaWeb', '\r\n\r\n# javaweb基础\r\n\r\n## 1、基本概念\r\n\r\n> 动态web资源开发的技术统称为JavaWeb\r\n\r\n+  引子：地址栏输入www.baidu.com\r\n\r\n1. 它应该在哪?     www.baidu:某个端口号（进行负载均衡之类的操作）/index.html\r\n2. 可以根据ping操作得到他的IP地址\r\n3. 能访问到的任何一个页面或者资源，都存在于某一个计算机上\r\n4. 掌握静态界面和动态界面的概念，动态界面需要什么技术？动态界面和静态界面各有什么优势和劣势\r\n\r\n## 2、web服务器\r\n\r\n### 2.1**流行的技术**\r\n\r\n####  	 1) ASP\r\n\r\n+ 基于C#\r\n+ 微软\r\n+ 国内最早流行的技术\r\n+ 在HTML中嵌入了VB的脚本，ASP +COM？\r\n+ 在ASP开发中，基本一个页面需要几千行，维护成本高，重构成本更高\r\n\r\n#### 2) PHP\r\n\r\n+ PHP开发速度快，功能强大，跨平台\r\n+ 无法承载大访问量情况（局限性）\r\n+ WordPress（开源的博客引擎）使用PHP写的\r\n\r\n#### 3) JSP/Servelt\r\n\r\n+ SUN公司主推的B/S架构服务器\r\n+ 基于Java\r\n+ 可以承载三高问题（高并发，高可用，高性能）带来的影响\r\n+ 语法像ASP\r\n\r\n###     2.2**常见的服务器**\r\n\r\n#### 1) IIS \r\n\r\n1. Window自带的服务器\r\n\r\n#### 2) Tomcat\r\n\r\n1. 下载安装\r\n2. 对目录要有一定的了解\r\n3. 在idea中配置Tomcat\r\n4. 核心配置文件\r\n   1. Tomcat\\apache-tomcat-8.5.63\\conf\\server.xml\r\n5. 常见bug的解决（端口占用等）\r\n\r\n> 我们访问    localhost:8080    端口出现了一个页面，这个过程中发生了什么呢\r\n\r\n+ localhost可以修改吗？\r\n  + 可以修改，需要在Windows底层和tomcat核心配置文件中修改主机名\r\n\r\n```\r\nC:\\Windows\\System32\\drivers\\etc\\hosts\r\n将127.0.0.1 对应的主机号改为 woshiyizhizhu\r\n```\r\n\r\n+ 8080端口可以修改吗？\r\n  + 可以\r\n\r\n\r\n\r\n\r\n\r\n> 一些默认端口号**\r\n>\r\n> + tomcat：8080\r\n>\r\n> + mysql：3306\r\n>\r\n> + http：80\r\n>\r\n> + https：443\r\n>\r\n> \r\n\r\n\r\n\r\n## 3、Http\r\n\r\n+ **谈一谈网站是如何访问的**\r\n\r\n  ![image-20210318111041743](E:\\typoradata\\img\\image-20210318111041743.png)\r\n\r\n### 3.1、什么是HTTP\r\n\r\n- 超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在[TCP](https://baike.baidu.com/item/TCP/33012)之上。\r\n\r\n- http\r\n\r\n  ​			默认端口：80\r\n\r\n- https\r\n\r\n  ​			默认端口： 443\r\n\r\n### 3.2、两个时代\r\n\r\n+ http1.0\r\n\r\n  ​	**HTTP/1.0:客户端与web服务器连接后，只能获得一个web资源**\r\n\r\n+ http2.0\r\n\r\n  ​     **HTTP/1.1:客户端与web服务器连接后可以获得多个web资源**\r\n\r\n### 3.3、Http请求（以百度为例）：\r\n\r\n- **客户端---发请求-->服务器**\r\n\r\n  ``` java\r\n  General:\r\n  Request URL: https://www.baidu.com/    请求地址\r\n  Request Method: GET       get方法/post方法           \r\n  Status Code: 200 OK       状态码\r\n  Remote Address: 127.0.0.1:7890       远程DNS地址\r\n  \r\n  ```\r\n\r\n#### 1、请求行\r\n\r\n  + **请求行中的请求方式**:Get,Post,HEAD,DELETE\r\n\r\n    1. get：一次请求携带的参数有限制，会在URL地址栏显示数据内容，不安全，但是高效\r\n    2. post:一次请求携带的参数没有限制，会在URL地址栏显示数据内容，安全，但不高效\r\n    3. HEAD\r\n\r\n> 面试题：简述GET和POST请求的异同点\r\n\r\n\r\n\r\n#### 2、请求头\r\n\r\n```java\r\n  Accept //告诉浏览器支持的数据类型\r\n  Accept-Encoding//告诉浏览器支持的编码格式\r\n  Accept-Language//告诉浏览器支持的语言\r\nCache-Control //缓存控制\r\n  Connection//告诉浏览器，请求完成是断开还是保持连接\r\nHOST\r\n```\r\n\r\n  \r\n\r\n  \r\n\r\n  \r\n\r\n### 3.4、Http响应（以百度为例）：\r\n\r\n- **服务器---响应-->客户端**\r\n\r\n  百度：\r\n\r\n  ```java\r\n  Cache-Control: private   //缓存控制\r\n  Connection: keep-alive   //连接状态\r\n  Content-Encoding: gzip   //编码\r\n  Content-Type: text/html;charset=utf-8 //类型\r\n  Date: Thu, 18 Mar 2021 03:38:11 GMT\r\n  Expires: Thu, 18 Mar 2021 03:38:11 GMT\r\n  Server: BWS/1.1\r\n  Set-Cookie: BDSVRTM=279; path=/\r\n  Set-Cookie: BD_HOME=1; path=/\r\n  Set-Cookie: H_PS_PSSID=33272_33710_33594_33570_26350_22159; path=/; domain=.baidu.com\r\n  Strict-Transport-Security: max-age=172800\r\n  Traceid: 1616038691062356762612472098429264318577\r\n  Transfer-Encoding: chunked\r\n  X-Ua-Compatible: IE=Edge,chrome=1\r\n  ```\r\n\r\n  #### 1.**响应体**\r\n\r\n  ```java\r\n  Accept: text/html\r\n  Accept-Encoding: gzip, deflate, br\r\n  Accept-Language: zh-CN,zh;q=0.9\r\n  Cache-Control: max-age=0\r\n  Connection: keep-alive\r\n  Location // 让网页重新定位\r\n  Refresh // 告诉客户端多久刷新一次\r\n  ```\r\n\r\n  #### 3.响应状态码\r\n\r\n  1. 200：请求响应成功\r\n  2. 3 XX：请求重定向\r\n  3. 404：找不到资源\r\n  4. 5XX:服务器代码错误\r\n     1. 502:网管错误\r\n\r\n> 面试题：当浏览器从地址栏输入地址到页面展示出来经历了什么？\r\n\r\n## 4、Maven的配置\r\n\r\n### 4.1为什么需要Maven？\r\n\r\njavaweb开发中需要大量的jar包，需要手动导入，为了简化这个步骤，Maven就是自动导入配置jar包的工具\r\n\r\n### 4.2 Maven的下载\r\n\r\n1. https://maven.apache.org/\r\n\r\n2. 了解Maven的目录，配置文件\r\n\r\n3. 配置环境变量\r\n\r\n   1. ​	先在系统变量里配置\r\n\r\n      ![image-20210322204258854](E:\\typoradata\\img\\image-20210322204258854.png)\r\n\r\n   2. 然后配置path环境变量\r\n\r\n      ![image-20210322204450066](E:\\typoradata\\img\\image-20210322204450066.png)\r\n\r\n### 4.3 创建Maven本地仓库\r\n\r\n1. 在Maven目录下新增maven-rapo文件夹\r\n\r\n2. 在settings.xml文件下新增\r\n\r\n```\r\n <localRepository>D:\\Maven\\apache-maven-3.6.3\\maven-repo</localRepository>\r\n```\r\n\r\n### 4.4 Maven阿里云镜像\r\n\r\n​		为什么需要这个？第一次配置Maven时会下载大量的数据，国内网络因为有墙的限制访问较慢，并且需要注意下载的位置\r\n\r\n```xml\r\n<id>nexus-aliyun</id>\r\n<mirrorOf>central</mirrorOf>\r\n<name>Nexus aliyun</name>\r\n<url>http://maven.aliyun.com/nexus/content/groups/public</url>\r\n```\r\n\r\n### 4.5、在idea中使用Maven\r\n\r\n1. Creat new project\r\n\r\n2. ![image-20210323000121624](E:\\typoradata\\img\\image-20210323000121624.png)\r\n\r\n3. 配置Maven的 \"gav\"\r\n\r\n   1. Group   : 组id      io.github.oliverloki\r\n   2. Artifactld : 项目名称    javaweb--maven\r\n   3. Version : 版本\r\n\r\n4. 配置地址\r\n\r\n   ![image-20210323134727886](E:\\typoradata\\img\\image-20210323134727886.png)\r\n\r\n5. 之后会下载很多东西，等待下载后出现下图说明配置成功\r\n\r\n   1. ![image-20210323134822857](C:\\Users\\yu\'chun\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210323134822857.png)\r\n\r\n6. 观察Maven中的repo文件夹多了什么东西，**并且在Setting中Bulid Tools中检查一下MavenHome的地址**\r\n\r\n   ![image-20210323142843729](E:\\typoradata\\img\\image-20210323142843729.png)\r\n\r\n7. 添加需要的文件夹（newdirectoty）\r\n\r\n### 4.6 其他操作\r\n\r\n1. 标记文件夹功能（idea的功能）\r\n\r\n   \r\n\r\n   ![image-20210323144456862](E:\\typoradata\\img\\image-20210323144456862.png)\r\n\r\n2. 了解一下Maven的侧边栏操作\r\n\r\n### 4.7 pom.xml（Maven的核心配置文件）\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<!--Maven版本和头文件-->\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <!--这里是刚才配置的gav-->\r\n  <groupId>github.oliverloki</groupId>\r\n  <artifactId>javaweb-maven-01</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n\r\n  <!-- Package 打包的方式\r\n  jar:Java应用\r\n  war:javaWeb应用\r\n  -->\r\n  <packaging>war</packaging>\r\n\r\n  <name>javaweb-maven-01 Maven Webapp</name>\r\n  <!-- FIXME change it to the project\'s website -->\r\n  <url>http://www.example.com</url>\r\n\r\n  <!--配置 -->\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.7</maven.compiler.source>\r\n    <maven.compiler.target>1.7</maven.compiler.target>\r\n  </properties>\r\n  <!--项目依赖-->\r\n  <!--maven官网有这个项目依赖，其强大之处在于可以导入某个jar包所依赖的jar包-->\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.11</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n  </dependencies>\r\n</project>\r\n```\r\n\r\n ### 4.8 Maven由于约定大于配置，会有一些bug\r\n\r\n1. ​	![image-20210323172834652](E:\\typoradata\\img\\image-20210323172834652.png)\r\n\r\n### 4.9  关于Maven父子工程的理解\r\n\r\n+ 父项目中会有\r\n\r\n```xml\r\n<moudles>\r\n	<moudle>servlet-01</moudle>\r\n</moudles>\r\n```\r\n\r\n+ 子项目会有\r\n\r\n  ```xml\r\n  <parent>\r\n          <artifactId>javaweb-02-Servlet</artifactId>\r\n          <groupId>github.oliverloki</groupId>\r\n          <version>1.0-SNAPSHOT</version>\r\n      </parent>\r\n  ```\r\n\r\n+ 父项目中的jar包子项目可以直接使用，但是子项目的项目父项目不能使用，类似于java的多态\r\n\r\n+ 父子工程示范目录\r\n\r\n  ![image-20210324165037766](E:\\typoradata\\img\\image-20210324165037766.png)\r\n\r\n\r\n\r\n### 4.10 Maven环境优化\r\n\r\n1. 修改xml为最新版本\r\n2. 将maven的目录结构补充完整\r\n\r\n## 5、Servlet\r\n\r\n### 5.1、Servlet简介\r\n\r\n+ sun公司开发的一种web技术\r\n+ 编写一个Servlet小程序只需要两个步骤\r\n  1. 编写一个类实现Servlet接口\r\n  2. 把开发好的Java类部署到服务器中\r\n\r\n+ Servlet接口sun公司有两个默认的实现类\r\n  1. HttpServlet\r\n  2. GenericServlet\r\n\r\n+ 编写第一个servlet**一个类继承HttpServlet并且重写其doGet和doPost方法**\r\n\r\n```java\r\npublic class helloservlet extends HttpServlet {\r\n\r\n    //由于get和post只是请求实现的不同方式，可以相互调用，因为其业务逻辑都一样\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n\r\n        PrintWriter writer = resp.getWriter(); //响应流\r\n        writer.print(\"hello world\");\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        super.doGet(req, resp);\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n​        	**重写方法的底层实现**\r\n\r\n![image-20210324184403880](E:\\typoradata\\img\\image-20210324184403880.png)\r\n\r\n\r\n\r\n+ **编写servlet的映射**\r\n\r\n1. 为什么需要映射，我们写的是java程序，但是需要浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务器中注册我们写的servlet，还需要一个浏览器可以访问的路径\r\n\r\n\r\n\r\n\r\n```xml\r\n<!--注册servlet-->\r\n    <servlet>\r\n        <servlet-name>hello</servlet-name>\r\n        <servlet-class>github.oliverloki.servlet.helloservlet</servlet-class>\r\n    </servlet>\r\n    <!--Servlet的请求路径-->\r\n    <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello</url-pattern>\r\n    </servlet-mapping>\r\n\r\n```\r\n\r\n+ **使用servlet3.0创建mysql时，可能会出现注解无效的问题**\r\n\r\n1. 解决方法：尝试删除 web.xml 的顶层标签的**metadata-complete** 属性\r\n\r\n+ **mapping**\r\n\r\n1. 一个Servlet可以指定一个映射路径\r\n\r\n2. 一个Servlet可以指定多个映射路径\r\n\r\n3. 一个Serclet可以指定通用映射路径\r\n\r\n   ```xml\r\n    <url-pattern>/hello</url-pattern>\r\n   ```\r\n\r\n### 5.2 Servlet常用对象\r\n\r\n#### 5.2.1、HttpServletContext\r\n\r\n+ web容器在启动的时候，会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用\r\n\r\n+ 应用(实际开发中几乎不会用到了)：\r\n\r\n  **1、共享数据**\r\n\r\n  ```java\r\n  //创建ServletContext对象类\r\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n  \r\n  \r\n          //this.getInitParameter()   初始化参数\r\n          //this.getServletConfig()   servlet配置\r\n          //this.getServletContext()  servlet上下文\r\n          ServletContext context = this.getServletContext();\r\n          String username = \"wangzhe\";\r\n          context.setAttribute(\"username\",username);//将一个数据保存在了servletcontext中\r\n  \r\n      }\r\n  ```\r\n\r\n  ```java\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          //\r\n          ServletContext servletContext = this.getServletContext();\r\n  \r\n          String username = (String) servletContext.getAttribute(\"username\");\r\n          response.setContentType(\"text/html\");\r\n          response.setCharacterEncoding(\"utf-8\");\r\n          response.getWriter().print(username);\r\n  \r\n  \r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  **2、初始化参数**\r\n\r\n  ```xml\r\n  <!--在webxml中配置一些初始化参数-->\r\n  <context-param>\r\n  	<param-name>url</param-name>\r\n  	<param-value>jdbc:mysql://localhost:3306/mybatis</param-value>\r\n  </context-param>\r\n  \r\n  ```\r\n\r\n  **3、请求转发**\r\n\r\n  \r\n\r\n  **4、读取资源文件**\r\n\r\n#### 5.2.2 HttpServletRequest\r\n\r\n+ 简介：在Servlet的API中，定义了一个HttpServletRequest接口，它继承自ServletRequest接口，专门用于封装HTTP的请求，由于HTTP请求包含着请求行、请求头和请求体三部分，因此在HttpServletRequest中分别定义了接收请求行、请求头和请求体的相关方法\r\n\r\n+ **主要应用**\r\n\r\n  1. **请求转发**\r\n  2. **获取前端传递的参数**\r\n\r\n+ **获取<请求行>相关信息的相关方法:**\r\n\r\n  ```java\r\n  getMethod()/*方法:返回请求方法，请求方法通常是GET或者POST,但也有可能是HEAD、PUT或者DELETE。*/ getRequestURI()/*方法:返回URI （URI是URL的从主机和端口之后到表单数据之前的那一部分）。\r\n    locallhost:8080/hello/get.htm1name=xiaohong&passWord=12345*/\r\n  getRemoteAddr()/*方法:该方法用于获取请求客户端的IP地址*/\r\n  getRemoteport()/*方法:该方法用于获取请求客户端的端口号*/\r\n  getLocalAddr()/*方法:该方法用于获取服务器当前接收请求的IP地址*/\r\n  getContextPath()/*方法:该方法用于获取URL中属于web应用程序的路径*/\r\n  getProtoco1()/*方法:该方法用于获取请求行中的协议名和版本*/\r\n  ```\r\n\r\n  \r\n\r\n+ **获取<请求头>的相关方法**:\r\n\r\n  ```java\r\n  getHeader(String name)/*该方法用于获取一个指定头字段的值，如果请求头中不包含该字段则返回nu11，如果包含多个该字段的值则获取第一个值*/\r\n  getIntHeader (String name）/*该方法用于获取指定头字段的值，并且将其值转为int类型，如果不存在该字段则返回-1，如果获取到的值不能转换为int则会发生NumberFormatException异常*/\r\n  getDateHeaders (String name)/*该方法用于获取指定头字段的值，并将其按照GMT时间格式转换成一个代表日期/时间的长整数*/\r\n  getHeaderNames()/*该方法用于获取所有包含请求头字段的Enumeration*/\r\n  \r\n  ```\r\n\r\n+ **获取<请求参数>**（get请求会将请求参数放在url中，而post请求会放在请求体中）\r\n\r\n  ```java\r\n  getParameter (String name)/*用于获取某个指定名称的参数值,如果请求中没有包含指定名称的参数,则返回nu11,如果有指定参数但是没有给设置值，则返回空串\"\"，如果包含多个该参数的值则返回第一个出现的参数值*/\r\n  getParameterNames()/*该方法用于返回一个包含请求消息中所有参数名的Enumernation*/\r\n  getParameterMap()/*该方法用于将请求中的所有参数和值装入一个map对象然后返回*/\r\n  ```\r\n\r\n  eg\r\n\r\n  ![image-20210329154143400](E:\\typoradata\\img\\image-20210329154143400.png)\r\n\r\n  ``````java\r\n  import javax.servlet.ServletException;\r\n  import javax.servlet.annotation.WebServlet;\r\n  import javax.servlet.http.HttpServlet;\r\n  import javax.servlet.http.HttpServletRequest;\r\n  import javax.servlet.http.HttpServletResponse;\r\n  import java.io.IOException;\r\n  import java.util.Enumeration;\r\n  \r\n  @WebServlet(name = \"httpservletrequest\", urlPatterns = \"/request\")\r\n  public class request对象 extends HttpServlet {\r\n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n  \r\n      }\r\n  \r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          //获取请求行相关信息\r\n          System.out.println(\"请求方法：\" + request.getMethod());\r\n          System.out.println(\"URI：\" + request.getRequestURI());\r\n          System.out.println(\"URL：\" + request.getRequestURL());\r\n          System.out.println(\"客户端IP地址：\" + request.getRemoteAddr());\r\n          System.out.println(\"客户端端口：\" + request.getRemotePort());\r\n          System.out.println(\"服务器接受请求的ip地址：\" + request.getLocalAddr());\r\n          System.out.println(\"url中属于web应用程序的路径：\" + request.getContextPath());\r\n          System.out.println(\"请求行中的协议名和版本：\" + request.getProtocol());\r\n  \r\n          //获取请求头相关信息\r\n          /*\r\n          getHeader(String name)该方法用于获取一个指定头字段的值，如果请求头中不包含该字段则返回nu11，如果包含多个该字段的值则获取第一个值\r\n          getIntHeader (String name）该方法用于获取指定头字段的值，并且将其值转为int类型，如果不存在该字段则返回-1，如果获取到的值不能转换为int则会发生NumberFormatException异常\r\n          getDateHeaders (String name)该方法用于获取指定头字段的值，并将其按照GMT时间格式转换成一个代表日期/时间的长整数\r\n          getHeaderNames()该方法用于获取所有包含请求头字段的Enumeration\r\n          */\r\n          Enumeration<String> headerNames = request.getHeaderNames();\r\n          while (headerNames.hasMoreElements()) {\r\n              String element = headerNames.nextElement();\r\n              System.out.println(element + \":\" + request.getHeader(element));\r\n          }\r\n          System.out.println(\"*******************\");\r\n  //**************************************\r\n  //需要掌握的getParamter和getParamatername\r\n          String name  = request.getParameter(\"name\");\r\n          String password = request.getParameter(\"password\");\r\n          System.out.println(\"姓名\"+ name);\r\n          System.out.println(\"密码\"+  password);\r\n  \r\n      }\r\n  }\r\n  \r\n  ``````\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>测试界面</title>\r\n  </head>\r\n  <body>\r\n  <center>\r\n      <h2>\r\n          <form action=\"request\" method=\"get\">\r\n              <p>账号：</p><input type=\"text\" name=\"name\">\r\n              <p>密码：</p><input type=\"text\" name=\"password\">\r\n              <input type=\"submit\" value=\"提交\">\r\n          </form>\r\n  \r\n  \r\n      </h2>\r\n  </center>\r\n  \r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n  1. 这里如果访问不到想要的html页面可以查看一下html的文件路径是否正确\r\n  2. form表单的action属性与urlpatterns相同\r\n\r\n#### 5.2.3 HttpServletResponse\r\n\r\n+ 简介：在Servlet的API，定义了一个HttpServletResponse接口，它继承自Serv1etResponse接口，专门用于封装HTTP的响应，由于HTTP响应包含着响应行、响应头和响应体三部分，因此在\r\n  HttpServletResponse中分别定义了发送响应行、响应头和响应体的相关方法\r\n\r\n+ 常见应用\r\n\r\n+ 一、下载文件\r\n\r\n  ```java\r\n  //在resourse中放置资源\r\n  \r\n  import java.io.IOException;\r\n  \r\n  import javax.servlet.ServletException;\r\n  import javax.servlet.ServletOutputStream;\r\n  import javax.servlet.annotation.WebServlet;\r\n  import javax.servlet.http.HttpServlet;\r\n  import javax.servlet.http.HttpServletRequest;\r\n  import javax.servlet.http.HttpServletResponse;\r\n  import java.io.FileInputStream;\r\n  import java.io.IOException;\r\n  \r\n  @WebServlet(name = \"DownloadServlet\",urlPatterns = \"/test01\")\r\n  public class DownloadServlet extends HttpServlet {\r\n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n  \r\n      }\r\n  \r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          //要获取下载文件的路径\r\n          String realPath = \"E:/java_study/javaweb/target/classes/1.png\";\r\n          System.out.println(\"下载文件的路径\"+realPath);\r\n  \r\n          // 下载的文件名是啥\r\n          //极其精妙的一个方法这里使用substring获取最后一个/之后的字符串\r\n          String filename = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1);\r\n          // 通过如下设置让浏览器能支持下载我们需要的文件\r\n          response.setHeader(\"Content-disposition\",\"attachment;filename=\"+filename);\r\n          // 获取下载文件的输入流\r\n          FileInputStream in = new FileInputStream(realPath);\r\n          // 创建缓冲区\r\n          int len = 0;\r\n          byte[] buffer = new byte[1024];\r\n          // 获取OutputStream对象\r\n          ServletOutputStream outputStream = response.getOutputStream();\r\n          // 将FileOutputStream流写入到buffer缓冲区,  使用OutputStream将缓冲区的数据输出到客户端\r\n          while((in.read())!=-1){\r\n              outputStream.write(buffer,0,len);\r\n          }\r\n          in.close();\r\n          outputStream.close();\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n+ 二、实现验证码切换\r\n\r\n  ```java\r\n  import javax.imageio.ImageIO;\r\n  import javax.servlet.ServletException;\r\n  import javax.servlet.annotation.WebServlet;\r\n  import javax.servlet.http.HttpServlet;\r\n  import javax.servlet.http.HttpServletRequest;\r\n  import javax.servlet.http.HttpServletResponse;\r\n  import java.awt.*;\r\n  import java.awt.image.BufferedImage;\r\n  import java.awt.image.RGBImageFilter;\r\n  import java.io.IOException;\r\n  import java.util.Random;\r\n  \r\n  @WebServlet(name = \"ImageServlet\",urlPatterns = \"/test02\")\r\n  public class ImageServlet extends HttpServlet {\r\n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n      }\r\n      \r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          //如何让浏览器五秒刷新一次\r\n          response.setHeader(\"refresh\",\"3\");\r\n  \r\n          //内存中创建图片\r\n          BufferedImage bufferedImage = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB);\r\n          //得到图片\r\n          Graphics2D graphics = (Graphics2D) bufferedImage.getGraphics();\r\n          //设置图片的背景颜色\r\n          graphics.setColor(Color.white);\r\n          graphics.fillRect(0,0,80,20);\r\n          //给图片写数据\r\n          graphics.setColor(Color.blue);\r\n          graphics.setFont(new Font(null,Font.BOLD,20));\r\n          graphics.drawString(makeNum(),0,20);\r\n          //告诉浏览器这个请求用图片的方式打开\r\n          response.setContentType(\"image/jpeg\");\r\n          //网站存在缓存，需要设置不让他缓存\r\n          response.setDateHeader(\"expires\",-1);\r\n          response.setHeader(\"Cache-COntrol\",\"no-cache\");\r\n          response.setHeader(\"Pragma\",\"no-cache\");\r\n  \r\n          //把图片写给浏览器\r\n          ImageIO.write(bufferedImage,\"jpg\",response.getOutputStream());\r\n  \r\n      }\r\n      //生成随机数\r\n      private String makeNum(){\r\n          Random random = new Random();\r\n          String s = random.nextInt(999999) + \" \";\r\n          StringBuffer stringBuffer = new StringBuffer();\r\n          for (int i = 0; i < 7- s.length();i++) {\r\n              stringBuffer.append(\"0\");\r\n          }\r\n          String ss = stringBuffer.toString() + s;\r\n          return ss;\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n+ **三、实现请求重定向**（三个response中唯一需要掌握的）\r\n\r\n> ​	常见需求：用户登录\r\n\r\n```java\r\nvoid sendRedirext(String var1) throws IOException\r\n```\r\n\r\n​					测试：\r\n\r\n```\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        response.sendRedirect(\"/w/test02\");\r\n    /*\r\n    	重定向的本质\r\n        response.setHeader(\"Location\",\"/w/test02\");\r\n        response.setStatus(302);\r\n     */\r\n    }\r\n```\r\n\r\n> 面试题：请你聊聊重定向和转发的区别\r\n\r\n​			    相同点\r\n\r\n​						1.页面都会实现跳转\r\n\r\n​				不同点\r\n\r\n​						1.请求转发的时候，url不会发生变化\r\n\r\n​						2.重定向时，url会发生变化\r\n\r\n+ **发送<响应行>**\r\n\r\n  ```java\r\n    setStatus(int status)\r\n    /*当Servlet向客户端回送响应消息时，需要设置一个状态码，该方法用于设置HTTP响应消息的状态码，并生成响应状态行。由于响应状态行中状态的描述直接和状态码相关，而HTTP协议版本由服务器决定，因此只需要设置该方法，就可以发送一个响应行，正常情况下，web服务器会默认发送一个200的状态码*/\r\n    sendError (int code）\r\n    /*该方法用于发送表示错误信息的状态码，例如404找不到访问的资源，他还有一种重载的形式sendError (intcode,String errorMessage) , errorMessage可以以文本形式显示在客户端浏览器*/\r\n    \r\n  ```\r\n\r\n  + **发送<响应头>**\r\n\r\n    ​	\r\n\r\n    ```java\r\n    addHeader(String name, String value)\r\n    /*该方法用来设置HTTP协议的响应头字段，其中name是响应头字段名，value是响应字段的值*/\r\n    setHeader(String name, String value)\r\n    /*该方法和addHeader相同，唯一的区别是addHeader可以重复添加一个同名的响应头字段，setHeader会覆盖之前添加的同名的响应头\r\n    */\r\n    addIntHeader(String name, int value)\r\n    setIntHeader(String name, int value)\r\n    /*\r\n    addIntHeader(String name,int value)、setIntHeader(Stringname,int value):这两个方法用于将value值为int的字段加入到响应头中\r\n    */\r\n    setContentType()\r\n    ```\r\n\r\n  + response对象发送请求体\r\n\r\n    由于在HTTP响应消息中，大量的数据都是通过响应体传递的，因此ServletResponse遵循以IO流传递大数据的设计理念，定义了两个与输出流相关的方法，具体如下:\r\n\r\n    1. getOutputStream()方法:该方法获取的字节流输出对象为**ServletOutputStream**类型，它是OutputStream的子类，因此可以直接输出字节数组中的二进制数据。\r\n\r\n  2. getWrite()方法:该方法获得的字符输出流对象是**PrintWriter**类型由于它可以直接输出文本类型，因此要输出网页文档，需要使用这个方法\r\n\r\n\r\n#### 5.2.4 Servlet的生命周期\r\n\r\n  + 什么是Servlet的生命周期\r\n\r\n    1. ​	指一个servlet对象从创建到销毁的过程\r\n\r\n  + Servlet接口及相关方法\r\n\r\n    ​	Serv1et接口是指:javax.servlet.Servlet\r\n\r\n  + init (ServletConfig）方法,初始化方法\r\n\r\n  + service (ServletRequest，ServletResponse）方法，每次访问都会调用来处理请求\r\n\r\n    + destory (）方法，销毁servlet方法\r\n\r\n    \r\n\r\n    ​	**具体实现时会继承HttpServlet接口**\r\n\r\n    + ​	HttpServ1et接口: javax.serv1et.http\r\n      ​	继承自Servlet接口，并重新实现了service方法，根据	不同请求方式调用不同的处理方法。service (HttpServletRequestHttpServletResponse）方法,获取请求方式，分别调用doGet(),或者doPost()方法。\r\n\r\n+ Servlet生命周期整个过程描述\r\n\r\n  1. ​	创建一个servlet实例，重写init方法，service方法。destory方法（简单输出hello即可）\r\n  2. 在service方法被执行的时候，会调用doGet和doPost方法\r\n    3. 启动tomcat，观察控制台的输出\r\n\r\n  \r\n\r\n  \r\n\r\n  \r\n\r\n+ **注意:**Servlet实例是单例的，即无论请求多少次Servlet，最多只有一个Serv1et实例，如果是多个客户端并发，同时访问Servlet的时候，服务器会启动多个线程分别执行Serv1et的service方法\r\n  原因:如果我们每次访问都创建一个Servlet实例,会占用和浪费过多的计算机资源\r\n\r\n#### 5.2.5 HttpServletConfig对象\r\n\r\n+ 简介：ServletConfig对象是它所对应的Servlet对象的相关配置信息\r\n\r\n+ 特点\r\n\r\n  1. 每一个Servlet对象都有一个ServletConfig对象和它相对应\r\n  2. ServletConfig对象在多个Servlet对象中是不可共享的\r\n\r\n+ 常见方法\r\n\r\n  ```java\r\n  //常见的Serv1etConfig对象的方法\r\n  getInitParameter(String name)//返回一个初始化变量的值\r\n  getInitParameterNames()//返回servlet初始化参数的所有名称\r\n  getServletContext()//获取ServletContext对象\r\n  4.getServletName()//获取Servlet的name配置值。\r\n  \r\n  ```\r\n\r\n#### /的意义\r\n\r\n![image-20210409152801530](E:\\typoradata\\img\\image-20210409152801530.png)\r\n\r\n## 6、Cookie Session\r\n\r\n###  6.1 保存会话的两种技术\r\n\r\n1. Cookie\r\n   + 客户端技术 （通过响应）\r\n2. session\r\n   + 服务器技术。利用这个技术，可以保存用户的会话信息，我们可以把信息或者数据放进session\r\n\r\n### 6.2 Cookie\r\n\r\n1. 从请求中拿到cookie信息\r\n\r\n2. 服务器相应给客户端cookie\r\n\r\n   ```java\r\n   Cookie[] cookies = request.getCookies(); //获得cookie\r\n   cookies.getName(); //获取cookie中的key\r\n   cookies.getValue(); //获取cookie中的value\r\n    new Cookie(\"username\",\"name\"); //新建一个cookie\r\n   cookie.setMaxage(24*60*60); // 设置cookie的有效期\r\n   resp.addCookie(cookie); //响应给客户端一个cookie\r\n   ```\r\n\r\n+ 一个cookie是否存在上限问题\r\n  1. 一个cookie只能保存一个信息\r\n  2. 一个web站点可以给浏览器垡村多个cookie，多存放20个cookie\r\n  3. cookie大小有限制4kb\r\n  4. 浏览器的上限在300个左右\r\n\r\n+ 删除cookie\r\n  1. 不设置有效期，关闭浏览器cookie自动失效\r\n  2. 设置有效期时间为0；\r\n\r\n### 6.3 Session（重点）\r\n\r\n+ Session简介\r\n\r\n  1. 服务器会给每个用户创建一个session对象，**一个session独占一个浏览器，只要浏览器没有关闭，session就存在**\r\n\r\n  2. 用户登录之后，整个网站都可以访问\r\n\r\n  3. 常用方法\r\n\r\n     ![image-20210330174148326](E:\\typoradata\\img\\image-20210330174148326.png)\r\n\r\n  ```java\r\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          //解决乱码问题\r\n          request.setCharacterEncoding(\"utf-16\");\r\n          response.setCharacterEncoding(\"utf-16\");\r\n          //浏览器的响应是一个html页面\r\n          response.setContentType(\"text/html;charst = utf-8\");\r\n          //得到session\r\n          HttpSession session = request.getSession();\r\n  \r\n          //void setAttribute(String var1, Object var2);\r\n      	//这个方法可以像session中存放一个键值对\r\n  	    session.setAttribute(\"username\",\"wangzhe\");\r\n  \r\n          //获取session得id\r\n          String id = session.getId();\r\n  \r\n          //判断是不是新创建的session\r\n          if(session.isNew()){\r\n              response.getWriter().write(\"session创建成功，ID:\" +session.getId());\r\n          }else{\r\n              response.getWriter().write(\"session已经存在，ID:\"+session.getId());\r\n          }\r\n  \r\n         /*\r\n        session在这段时间做了什么？是\r\n        Cookie cookie = new 				    Cookie(\"JSESSIONID\",\"3452BA94C9044AD349770A6A5D9BC08A\");\r\n        response.addCookie(cookie);\r\n        */\r\n      \r\n      //session注销\r\n          session.removeAttribute(\"name\");\r\n          //注销session后id消失，但是会马上生成一个新id\r\n          session.invalidate();\r\n      }\r\n  }\r\n  ```\r\n\r\n  会话自动过期；web.xml配置\r\n\r\n  ```xml\r\n    //设置session的失效时间\r\n    <session-config>\r\n      <session-timeout>15</session-timeout>\r\n    </session-config>\r\n  ```\r\n\r\n### 6.4、Session和Cookie的区别\r\n\r\n1. Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）\r\n2. Session把用户的数据写到用户独占的session中，服务器端保存（保存重要的信息，减少服务器资源的浪费）\r\n3. session对象由服务创建\r\n\r\n\r\n\r\n使用场景：\r\n\r\n1. 保存一个登录用户的信息\r\n2. 购物车信息\r\n3. 在整个网站中经常使用的数据保存在session\r\n\r\n## 7、JSP\r\n\r\n### 7.1、什么是jsp\r\n\r\nJava Server Pages：java服务器端页面，也和servlet一样，用于动态web技术\r\n\r\n特点：\r\n\r\n1. 写jsp就像是再写HMTL\r\n2. JSP页面中嵌入了java代码，为用户提供动态数据\r\n\r\n### 7.2、JSP原理\r\n\r\n思路：JSP到底是怎么执行的\r\n\r\n+ 代码层面没有问题\r\n\r\n+ 关注其服务器内部工作\r\n\r\n+ 在tomcat工作（work）目录中发现页面转变成了java程序   **= > **不管访问什么资源，其实都是在访问servlet\r\n\r\n+ JSP最终也会被转换为一个java类\r\n\r\n+ JSP本质上就是一个servlet\r\n\r\n  ```java\r\n  //初始化  \r\n  public void _jspInit() {\r\n    }\r\n  //销毁\r\n    public void _jspDestroy() {\r\n    }\r\n  //JSPService\r\n  public void _jspService(HttpServletRequest request,HttpServletResponse response)\r\n  ```\r\n\r\n  1. 判断请求\r\n\r\n  2. jsp内置了一些对象\r\n\r\n     ```java\r\n         final javax.servlet.jsp.PageContext pageContext; //页面上下文\r\n         javax.servlet.http.HttpSession session = null; //session\r\n         final javax.servlet.ServletContext application;  //applicationContext\r\n         final javax.servlet.ServletConfig config;  //config\r\n         javax.servlet.jsp.JspWriter out = null;  //out\r\n         final java.lang.Object page = this;  //当前页\r\n     	HttpServletRequest request  //请求\r\n     	HttpServletResponse response  //响应\r\n     \r\n     ```\r\n\r\n### 7.3、JSP基础语法\r\n\r\n```jsp\r\n<%=   %>     作用:用来将程序的输出显示到客户端\r\n------------------------------------------------\r\n<%\r\n作用：内嵌代码块\r\n%>\r\n------------------------------------------------\r\n<%!\r\n作用：JSP声明-->会被编辑到java的类中，其他的jsp代码会被生成到jspservice方法中\r\n%>\r\n------------------------------------------------\r\n\r\n\r\nHTML的注释会在客户端显示\r\nJSP的注释会在客户端显示\r\n\r\n\r\n```\r\n\r\n### 7.4、JSP指令\r\n\r\n+ Page指令\r\n\r\n+ include指令\r\n\r\n+ taglib指令\r\n\r\n  ```jsp\r\n  <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%>\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n```java\r\n//自定义错误界面吗，本质上使用请求转发的方式进行跳转\r\n<%@ page errorPage=\"error.jsp\" %>\r\n    \r\n    \r\n    \r\n```\r\n\r\n```xml\r\n      <error-page>\r\n              <error-code>404</error-code>\r\n              <location>/errorpage/error_404.jsp</location>\r\n       </error-page>\r\n       <error-page>\r\n              <error-code>500</error-code>\r\n              <location>/errorpage/error_500.jsp</location>\r\n       </error-page>\r\n```\r\n\r\n\r\n\r\n### 7.5、JSP9大内置对象\r\n\r\n+ PageContext\r\n+ Request\r\n+ Response\r\n+ Session\r\n+ Application【ServletContext】\r\n+ config 【ServletConfig】\r\n+ out\r\n+ ~~page    不用了解~~\r\n+ exception\r\n\r\n### 7.6、作用域\r\n\r\n```java\r\n    pageContext.setAttribute(\"name1\",\"zhangsan\");//保存的数据在一个界面中有效\r\n    request.setAttribute(\"name2\",\"lisi\");//保存的数据在一次请求中有效，请求转发会携带这个数据\r\n    session.setAttribute(\"name3\",\"wangmazi\");//保存数据在一次会话中有效，从打开服务器到关闭服务器\r\n    application.setAttribute(\"name4\",\"guoer\");//保存数据在服务器中保存，只要服务器不崩就有效\r\n```\r\n\r\nrequest：客户端向服务器发送请求产生的数据，用户看完没用的，比如：新闻\r\n\r\nsession：客户端向服务器发送请求产生的数据，用户看完还有用，比如：购物车\r\n\r\napplication：客户端向服务器发送请求产生的数据，其他用户还有用，比如：聊天内容\r\n\r\n### 7.7 JSP标签，JSTL标签，EL表达式\r\n\r\nEL表达式：    **${ }**\r\n\r\n+ 用处：从四大域中获取数据\r\n\r\n  EL获取pageContext域中的值: ${pageScope.key}​\r\n\r\n  EL获取request域中的值: ${requestScope.key}​\r\n\r\n  EL获取pageContext域中的值: ${sessionScope.key}​\r\n\r\n  EL获取pageContext域中的值: ${applicationScope.key}​\r\n\r\n  \r\n\r\n\r\n\r\nJSP标签：\r\n\r\n![image-20210407175450907](E:\\typoradata\\img\\image-20210407175450907.png)\r\n\r\n```jsp\r\n//引入一个界面\r\n<jsp:include page=\"\"></jsp:include>\r\n//请求转发\r\n<jsp:forward page=\"\">\r\n    //存入一个键值对\r\n    <jsp:param name=\"\" value=\"\"/>\r\n</jsp:forward>\r\n```\r\n\r\nJSTL表达式\r\n\r\n​	**JSTL标签库的使用就是为了弥补HTML标签的不足**，**但功能和Java是一样的**\r\n\r\n​	使用方法：\r\n\r\n1. 引入对应得taglib：https://www.runoob.com/jsp/jsp-jstl.html\r\n2. 核心标签\r\n\r\n​	核心标签是最常用的 JSTL标签。引用核心标签库的语法如下：\r\n\r\n```\r\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\r\n```\r\n\r\n+ ~~格式化标签~~\r\n\r\n+ ~~SQL标签~~\r\n\r\n+ ~~XML标签~~\r\n\r\n## 8、Javabean--实体类\r\n\r\nJavaBean有特定的写法：\r\n\r\n+ 必须要有一个无参构造\r\n+ 属性必须私有化\r\n+ 必须有set/get方法\r\n\r\n**一般用来和数据库的字段做映射 ORM**\r\n\r\nORM：对象关系映射\r\n\r\n+ 表--> 类\r\n+ 字段 -->属性\r\n+ 行记录 --> 对象\r\n\r\n| id   | name    | age  | address |\r\n| :--- | ------- | ---- | ------- |\r\n| 1    | wangyi  | 18   | 1       |\r\n| 2    | wanger  | 19   | 2       |\r\n| 3    | wangsan | 20   | 3       |\r\n\r\n```java\r\nclass People{\r\n    private int id;\r\n    private String name;\r\n    private String address;\r\n}\r\n```\r\n\r\n\r\n\r\n## 9、MVC架构\r\n\r\n### 9.1、什么是MVC: \r\n\r\n+ Model  模型\r\n  1. 业务处理：业务逻辑（Service）\r\n  2. 数据持久层：CRUD (Dao)\r\n+ View  视图\r\n  1. 展示数据\r\n  2. 提供链接发起servlet请求 （a ,img ,form）\r\n+ Controller   控制器\r\n  1. 接受用户请求 (Request :请求参数 ，Session信息)\r\n  2. 交给业务层处理对应的业务代码\r\n  3. 控制视图的跳转\r\n\r\n```\r\n登录 ---> 接受用户的请求 --->处理用户的请求(获取用户登录参数 username.password) ----> 交给业务层处理登录业务(判断用户名密码是否正确) ---> Dao层查询用户名和密码是否正确 ---> 数据库\r\n```\r\n\r\n\r\n\r\n早些年用户直接访问控制层，控制层就可以直接操作数据库\r\n\r\n![image-20210408151550823](E:\\typoradata\\img\\image-20210408151550823.png)\r\n\r\n```\r\n优化：\r\nservlet--CRUD--数据库\r\n弊端：程序十分臃肿，不利于维护\r\nservlet的代码中：处理请求，响应，试图跳转，处理JDBC,处理业务代码，处理逻辑代码\r\n-----------------------------------------------------\r\n利用架构思想优化：\r\n架构：没有什么是加一层解决不了的\r\n\r\n中间件举例：\r\n程序员调用\r\n	|\r\n	|\r\n  JDBC 中间件\r\n    |\r\n    |\r\nMySQL Oracle SqlServer\r\n```\r\n\r\n![image-20210409153004504](E:\\typoradata\\img\\image-20210409153004504.png)\r\n\r\n\r\n\r\n## 10、过滤器 Filter(重点)\r\n\r\nFilter：过滤器，用来过滤网站的数据;\r\n\r\n+ 处理中文乱码\r\n+ 登录验证\r\n\r\n### 1、Fliter开发步骤\r\n\r\n1. 导包\r\n\r\n2. 编写过滤器\r\n\r\n   ```java\r\n   import javax.servlet.*;\r\n   import java.io.IOException;\r\n   \r\n   public class Filter implements javax.servlet.Filter {\r\n       //编写过滤器需要重写三个方法\r\n       //销毁\r\n       public void destroy() {\r\n           System.out.println(\"filter销毁\");\r\n       }\r\n       //chain: 链\r\n       /*\r\n       1、过滤器中的代码，在过滤特定请求是都会执行\r\n       2、\r\n        */\r\n       public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\r\n           req.setCharacterEncoding(\"utf-8\");\r\n           resp.setCharacterEncoding(\"utf-8\");\r\n           resp.setContentType(\"text/html;charset=utf-8\");\r\n           System.out.println(\"filter执行前\");\r\n           //起到一个放行作用\r\n           chain.doFilter(req,resp);  //如果不写，程序到这里就被拦截停止了\r\n           System.out.println(\"filter执行后\");\r\n       }\r\n   \r\n       //web服务器启动就马上开始初始化\r\n       public void init(FilterConfig config) throws ServletException {\r\n           System.out.println(\"fliter初始化\");\r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n3. web.xml中配置filter\r\n\r\n   ```xml\r\n       <filter>\r\n               <filter-name>Filter</filter-name>\r\n               <filter-class>org.filter.Filter</filter-class>\r\n       </filter>\r\n       <filter-mapping>\r\n           <filter-name>Filter</filter-name>\r\n           <!--只要是/servlet的任何请求，都会经过这个过滤器-->\r\n           <url-pattern>/servlet/*</url-pattern>\r\n       </filter-mapping>\r\n   \r\n       <servlet>\r\n           <servlet-name>showServlet</servlet-name>\r\n           <servlet-class>org.servlet.showServlet</servlet-class>\r\n       </servlet>\r\n       <servlet-mapping>\r\n           <servlet-name>showServlet</servlet-name>\r\n           <url-pattern>/show</url-pattern>\r\n       </servlet-mapping>\r\n       <servlet-mapping>\r\n           <servlet-name>showServlet</servlet-name>\r\n           //走这个路径会解决乱码问题\r\n           <url-pattern>/servlet/show</url-pattern>\r\n       </servlet-mapping>\r\n   ```\r\n\r\n   ### 2、Filter常见用途\r\n\r\n   + \r\n\r\n## 11、监听器\r\n\r\n### 1、编写一个监听器\r\n\r\n实现监听器的接口\r\n\r\n```java\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.http.HttpSessionEvent;\r\nimport javax.servlet.http.HttpSessionListener;\r\n//统计网络在线人数 ： 统计session\r\npublic class OnlineCountListener implements HttpSessionListener{\r\n\r\n    //创建session监听\r\n    //一旦创建一个session，会触发一次这个事件\r\n    @Override\r\n    public void sessionCreated(HttpSessionEvent se) {\r\n        ServletContext servletContext = se.getSession().getServletContext();\r\n\r\n        System.out.println(se.getSession().getId());\r\n\r\n        Integer onlineCount = (Integer)servletContext.getAttribute(\"OnlineCount\");\r\n\r\n        if(onlineCount == null){\r\n            onlineCount  = new Integer(1);\r\n        }else {\r\n            int count = onlineCount.intValue();\r\n            onlineCount = new Integer(count++);\r\n        }\r\n        servletContext.setAttribute(\"OnlineCount\",onlineCount);\r\n    }\r\n\r\n    @Override\r\n    //销毁session监听\r\n    public void sessionDestroyed(HttpSessionEvent se) {\r\n        ServletContext servletContext = se.getSession().getServletContext();\r\n        Integer onlineCount = (Integer)servletContext.getAttribute(\"OnlineCount\");\r\n\r\n        if(onlineCount == null){\r\n            onlineCount  = new Integer(1);\r\n        }else {\r\n            int count = onlineCount.intValue();\r\n            onlineCount = new Integer(count--);\r\n        }\r\n        servletContext.setAttribute(\"OnlineCount\",onlineCount);\r\n    }\r\n}\r\n```\r\n\r\n在xml中配置\r\n\r\n```xml\r\n  <listener>\r\n        <listener-class>org.listener.OnlineCountListener</listener-class>\r\n    </listener>\r\n```\r\n\r\n\r\n\r\n### 2、GUI编程中常用到监听器\r\n\r\n```java\r\npackage org.listener;\r\n\r\nimport java.awt.*;\r\nimport java.awt.event.WindowAdapter;\r\nimport java.awt.event.WindowEvent;\r\n\r\npublic class testJUI {\r\n    public static void main(String[] args) {\r\n        //新建一个窗体\r\n        Frame frame = new Frame(\"中秋节快乐\");\r\n        //面板\r\n        Panel panel = new Panel(null);\r\n        //设置窗体的布局\r\n        frame.setLayout(null);\r\n\r\n        frame.setBounds(300,300,500,500);\r\n\r\n        frame.setBackground(new Color(0,0,255));\r\n\r\n        panel.setBounds(50,50,300,300);\r\n\r\n        panel.setBackground(new Color(0,255,0));\r\n\r\n        frame.add(panel);\r\n        frame.setVisible(true);\r\n\r\n        //给这个面板增加一些监听事件\r\n        frame.addWindowListener(new WindowAdapter() {\r\n            @Override\r\n            public void windowOpened(WindowEvent e) {\r\n                System.out.println(\"打开\");\r\n            }\r\n\r\n            @Override\r\n            public void windowClosing(WindowEvent e) {\r\n                System.out.println(\"关闭ing\");\r\n            }\r\n\r\n            @Override\r\n            public void windowClosed(WindowEvent e) {\r\n                System.out.println(\"关闭了\");\r\n            }\r\n\r\n            @Override\r\n            public void windowActivated(WindowEvent e) {\r\n                System.out.println(\"激活\");\r\n            }\r\n\r\n            @Override\r\n            public void windowDeactivated(WindowEvent e) {\r\n                System.out.println(\"未激活\");\r\n            }\r\n\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 1, 'javaweb学习笔记', 0, 1, 2, '2021-10-19 15:53:24', NULL);
INSERT INTO `blog` VALUES (2, 'Git', '# Git学习笔记01 --- 知识储备\r\n\r\n## 概述\r\n\r\n> 提出问题: git是什么呢？\r\n>\r\n> 答: Git是目前世界上最先进的分布式版本控制系统\r\n\r\n因此在学习git之前必须要了解的一个概念-------版本控制\r\n\r\n### 什么是版本控制\r\n\r\n+ 版本控制( Revision control )是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\r\n+ 不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。用的比较多的是 SVN 和 Git\r\n+ 简单说就是用于管理多人协同开发项目的技术\r\n\r\n### 版本控制的具体功能\r\n\r\n1. 实现跨区域多人协同开发\r\n2. 追踪和记载一个或者多个文件的历史记录·组织和保护你的源代码和文档\r\n3. 统计工作量\r\n4. 并行开发、提高开发效率跟踪记录整个软件的开发过程减轻开发人员的负担，节省时间，同时降低人为错误\r\n\r\n**没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。**\r\n\r\n### Git简介\r\n\r\n+ Git是开源的分布式版本控制系统\r\n+ Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件\r\n+ Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等\r\n\r\n### 主流的版本控制有哪些\r\n\r\n+ Git\r\n+ SVN\r\n+ CVS\r\n\r\n### Git与SVN的区别\r\n\r\n- **1、Git 是分布式的，SVN 不是**：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。\r\n- **2、Git 把内容按元数据方式存储，而 SVN 是按文件：**所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。\r\n- **3、Git 分支和 SVN 的分支不同：**分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。\r\n- **4、Git 没有一个全局的版本号，而 SVN 有：**目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。\r\n- **5、Git 的内容完整性要优于 SVN：**Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\r\n\r\n## 版本控制系统的工作模式\r\n\r\n版本控制系统的工作模式主要有两种，集中式工作模式和分布式工作模式\r\n\r\n### （一）集中式工作模式\r\n\r\n​		为了让不同系统上的开发者能够协同工作，集中化的版本控制系统应运而生。集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\r\n\r\n![image-20210602223109348](https://i.loli.net/2021/06/02/e68hlQVajYGzKUM.png)\r\n\r\n+ 存在的问题：\r\n  1. 一旦服务器出现问题，所有的客户机将无法更新到最新版本，并且无法恢复到指定的版本。因为所有版本信息都在中央版本库中。\r\n  2. 必须具有网络环境，单机无法实现版本控制。\r\n  3. 客户机之间无法直接进行联系，无论中央版本服务器是否出现问题。CVS,SVN 都是集中式版本控制系统。\r\n\r\n### （二）分布式工作模式\r\n\r\n​		分布式版本控制系统中无需中面版本库服务器，每台客户机都具有独立的版本控制\r\n功能，多台客户机之间相连就可以实现文件共享及版本管理。\r\n\r\n![image-20210602224003509](https://i.loli.net/2021/06/02/MqpAP8zrK6LIlFo.png)\r\n\r\n+ 分布式工作模式的好处\r\n\r\n  无需网络环境也可以进行版本控制,在网络环境下可以实\r\n  现协同工作\r\n\r\n  \r\n\r\n## Git的工作模式\r\n\r\n**包含：集中式工作模式，开源社区工作模式**\r\n\r\n+ 集中式工作模式\r\n\r\n  Git为了便于客户机之间的协同工作,Git版本控制系统一般会设置一个中央版本库\r\n  服务器，目的是让所有客户机都从该主机更新版本,提交最新版本。该工作模式下的客\r\n  户机地位都平等。\r\n\r\n+ 开源社区工作模式\r\n\r\n  1. 对于开源软件开源社区的协作开发模式,不可能让所有人都具有修改中央版本库的权限，让\r\n     不同的客户机对中央版本库的不同操作权限，将有利于维护开源软件的安全性。\r\n  2. 你可以下载某一个仓库到你的本地仓库，但是你如果向原作者提交修改代码，需要原作者同意并且修改整合后才能提交成功\r\n\r\n## Git工作流程\r\n\r\n1. 初始化一个本地版本库，每个版本库仅需要执行一次。。\r\n2. 将中央版本库内容克隆到本地版本库，每个客户机仅需要执行一次。 。\r\n3. 添加指定文件到版本控制管理(只是添加到暂存区)。\r\n4. 将修改操作操作到本地版本库(将暂存区的内容提交到本地版本库)。\r\n5. 将本地版本库中的修改内容“推送”到中央版本库，客户机需要在一阶段性工作完成之\r\n6. 后或在某些时间点(下班，周五)将修改过的内容备份到中央版本库，方便他人更新到\r\n   最新的代码。\r\n7. 将中央版本库中的变化内容“拉取”本地版本库，客户机需要不时的更新才可以获取最\r\n   新的内容\r\n\r\n\r\n\r\n# 目录\r\n\r\n\r\n\r\n## Windows下Git的卸载\r\n\r\n1. 清理系统环境变量\r\n\r\n   ![image-20210602235228422](https://i.loli.net/2021/06/02/RgG9MYzmO3BPWcx.png)\r\n\r\n2. 在Windows设置中找到册程序卸载直接卸载Git即可\r\n\r\n   ![image-20210602235423816](https://i.loli.net/2021/06/02/5wHxPmaM2WQlZDt.png)\r\n\r\n   两步之后即可将git卸载干净\r\n\r\n   \r\n\r\n## Windows下Git下载安装\r\n\r\n> 官网：https://git-scm.com/\r\n>\r\n> 如果下载比较慢的话可以用镜像 下载：https://npm.taobao.org/mirrors/git-for-windows/\r\n\r\n1. 下载可执行文件后直接双击安装\r\n\r\n   ![image-20210602235818834](https://i.loli.net/2021/06/02/UEowDHLpzm7kqiy.png)\r\n\r\n2. 点击下一步完成安装，注意安装目录即可\r\n\r\n   ![image-20210603000348787](https://i.loli.net/2021/06/03/fH824ZAP6RNUnqx.png)\r\n\r\n**安装成功后在开始菜单中会有Git项，菜单下有3个程序∶任意文件夹下右键也可以看到对应的程序!**\r\n\r\n![image-20210603000808890](https://i.loli.net/2021/06/03/rcDEI18GVwxYmZJ.png)\r\n\r\n+ Git Bash : Unix与Linux风格的命令行，使用最多，推荐最多\r\n+ Git CMD : Windows风格的命令行\r\n+ Git GUI:图形界面的Git，不建议初学者使用，尽量先熟悉常用命令\r\n\r\n## 环境变量的配置\r\n\r\n在安装Git时，它本身已经在系统环境变量里配置了一个环境变量，我们鼠标右键就可以在任意一个文件夹下使用git，不需要手动配置了\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210603150931385.png)\r\n\r\n## 如何验证Git安装成功\r\n\r\n进入Git bash\r\n\r\n```bash\r\n#输入以下命令\r\ngit --version\r\n```\r\n\r\n若出现对应版本号，说明git安装成功\r\n\r\n![image-20210604004518446](https://i.loli.net/2021/06/04/WzPTA9b3ocyGVUk.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Git学习笔记03 --- Git详细操作\r\n\r\n## 常用Linux命令\r\n\r\n> 因为Git Bash操作基本是使用Linux命令，所以在学习Git之前需要掌握一些基本的Linux指令\r\n\r\n在linux中，都是使用命令行进行操作\r\n\r\n1. `cd 目录名`  改变目录\r\n\r\n2. `cd ..`   回退到上一个目录，直接cd进入默认目录\r\n\r\n3. `pwd`  显示当前所在的目录路径。\r\n\r\n4. `ls`  列出当前目录中的所有文件\r\n\r\n5. `touch 新文件名`   新建一个文件如touch index.js就会在当前目录下新建一个index.js文件\r\n\r\n6. `rm: ` 删除一个文件, rm index.js 就会把index.js文件删除。\r\n\r\n7. `mkdir ` 新建一个目录,就是新建一个文件夹。\r\n\r\n8. `rm -r`  删除一个文件夹, rm -r src删除src目录\r\n\r\n   ```\r\n   rm-rf / 在linux下是循环清除全部文件\r\n   ```\r\n\r\n9. `mv`  移动文件, mv index.html src index.html是我们要移动的文件, src是目标文件夹,当然,这样写;必夹在同一目录下。\r\n\r\n10. ` reset ` 重新初始化终端/清屏\r\n\r\n11. `clear`  清屏。\r\n\r\n12. `history`  查看命令历史\r\n\r\n13. `help`  帮助\r\n\r\n14. `exit ` 退出\r\n\r\n15. `#`  表示注释\r\n\r\n\r\n\r\n```\r\ngit config --global user.name \"你的用户名\"\r\ngit config --global user.email \"你的邮箱地址\"\r\n```\r\n\r\n`git config -l `显示当前配置\r\n\r\n![image-20210603143822317](E:\\markdown_data\\git\\PvCyqrzcHBbLSGZ.png)\r\n\r\n## 工作区域\r\n\r\n**Git本地有三个工作区域:工作目录( Working Directory )、暂存区(Stage/index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下∶**\r\n\r\n![image-20210603151418488](https://i.loli.net/2021/06/03/EC5eGOtzZrsIXlp.png)\r\n\r\n+  **Workspace :工作区，就是你平时存放项目代码的地方**\r\n+  **Index / Stage:暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息**\r\n+  **Repository :仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本**\r\n+  **Remote :远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换**\r\n\r\n## 工作流程\r\n\r\n![image-20210603151846602](https://i.loli.net/2021/06/04/HZyn6QK3bOpG9Cz.png)\r\n\r\n+ **git的工作流程一般是这样的∶**\r\n\r\n1. **在工作目录中添加、修改文件;** \r\n\r\n2. **将需要进行版本管理的文件放入暂存区域;**\r\n\r\n   `git add .`\r\n\r\n3. **将暂存区域的文件提交到git仓库。**\r\n\r\n   `git commit`\r\n\r\n​            4.提交到远程仓库\r\n\r\n​                `git puch`\r\n\r\n​				因此，git管理的文件有三种状态︰已修改( modified ) ,已暂存 ( staged ) ,				已提交(committed)\r\n\r\n\r\n\r\n## Git用户分类与创建\r\n\r\n> 使用Git前需要做的基本配置\r\n\r\n**以下两点很重要**\r\n\r\n+ 作为版本控制系统的客户端，每台客户机对版本库的所有提交操作都需要注明操作者身份，所以客户机首先需要进行自我身份的注册，即创建用户。**Git 要求“用户名和Email\"这两样信息是必不可少的**。Git具有三种不同的创建方式，会产生三种不同作用域的用户。这三种创建方式的用户信息会写到三个不同的配置文件中。这三种用户的创建均需要使用git config 命令，只不过使用的选项不同。\r\n+ 这三种创建方式的创建的用户作用域由大到小依次是:`系统用户`，`全局用户`与`本地库用户`。在多种用户都进行了创建的前提下，小范围用户会覆盖大范围用户，即默认会以小范围用户操作Git。\r\n\r\n**查看用户配置信息**\r\n\r\n```bash\r\n#查看系统用户配置信息\r\ngit config --system --list\r\n#查看全局用户配置信息\r\ngit config --global --list\r\n#查看本地用户配置信息\r\ngit config  --list\r\n```\r\n\r\n**使用GIt Bash创建不同用户**\r\n\r\n1. 系统用户:当前主机系统中所有用户均可以使用的Git用户\r\n\r\n   ```bash\r\n   git config --system user.name\"创建的用户名\"\r\n   git config --system user.email\"创建的用户邮箱\"\r\n   ```\r\n\r\n2. 全局用户:当前主机系统的当前登录用户可以使用的Git用户\r\n\r\n   ```bash\r\n   git config  user.name\"创建的用户名\"\r\n   git config  user.email\"创建的用户邮箱\"\r\n   ```\r\n\r\n   \r\n\r\n3. 本地库用户:只能对当前的本地版本库进行提交的Git用户\r\n\r\n   ```bash\r\n   git config --system user.name\"创建的用户名\"\r\n   git config --system user.email\"创建的用户邮箱\"\r\n   ```\r\n\r\n> 小范围的值一旦设定，值会将前面的值覆盖，即起作用的将是小范围用户那一组。\r\n\r\n**所有的配置其实都以文件的形式保存在本地**\r\n\r\n![](https://i.loli.net/2021/06/03/JFw2bTzOGeYDBE8.png)\r\n\r\n![image-20210603150002089](https://i.loli.net/2021/06/03/eGTabm69C1DO2X5.png)\r\n\r\n\r\n\r\n## 本地仓库的搭建\r\n\r\n**本地仓库的搭建有两种方式**\r\n\r\n### （一）初始化本地仓\r\n\r\n```bash\r\ngit init\r\n```\r\n\r\n![image-20210603152624958](https://i.loli.net/2021/06/03/j6iOPb1kMyCVtBR.png)\r\n\r\n执行之后文件夹多了一个目录（注意这是隐藏文件）\r\n\r\n![image-20210603153859228](https://i.loli.net/2021/06/03/7pIVr4zJasToMiU.png)\r\n\r\n> **这个目录下包含了当前版本库正常工作所需要的所有内容:暂存区文件，版本记录文件，配置文件等。换句话，如果你想从项目中删除Git的版本控制，但又要保留项目原文件，那么只需要将这个.git目录删除即可。这样话，这个项目就与Git没有任何关系。**\r\n\r\n### （二）从github / gitee 导入\r\n\r\n\r\n\r\n```\r\ngit clone url\r\n```\r\n\r\n从github或者gitee上任何一个项目都可以克隆到本地\r\n\r\n例子：\r\n\r\n![image-20210603154624600](https://i.loli.net/2021/06/03/uOZcSCbeKEtaPpR.png)\r\n\r\n![image-20210603155028231](https://i.loli.net/2021/06/03/zqXYH1gtOjTPs2N.png)\r\n\r\n## Git 常用命令\r\n\r\n> ![image-20210603152410206](https://i.loli.net/2021/06/03/EYian3cXlmV26O9.png)\r\n\r\n```bash\r\n#查看文件状态\r\ngit status\r\n\r\n#添加文件--该命令的作用是告诉Git系统，将指定文件的当前快照写入到版本库暂存区。即将文件交给Git进行版本管理。\r\n#添加全部文件\r\ngit add .\r\n#添加指定文件\r\ngit add filename\r\n\r\n#提交到本地仓库--提交操作就通过命令将Git暂存区中的文件快照永久性地写入到本地仓库中  （提交时使用 -m 给出一个操作提示信息）\r\ngit commit -m\"这次修改了什么东西\"\r\n\r\n#提交到\r\n\r\n\r\n#查看区别--比较不同工作区域文件的异同\r\n	# 1)比较工作区与暂存区\r\n	git diff filename\r\n	# 2）比较暂存区与本地库\r\n	git diff --cached filename\r\n	\r\n#撤销修改内容--对于己修改过的文件内容需要进行撒销，根据修改内容已经出现的位置可以分为三种情况:(相当于git的CTRL+Z)\r\n	# 1）仅仅是工作区中内容进行了修改，还未添加add到暂存区\r\n	git checkout -- filename\r\n	\r\n	# 2）已经add添加到暂存区，但是还未commit提交到本地版本库\r\n	git reset HEAD filename\r\n	\r\n	# 3）已经提交commit到本地版本库--无法撤销修改，可以回退到之前版本\r\n		#查看历史版本\r\n		git log  #详细信息\r\n		git log --pretty=oneline  #简单显示\r\n		git log --pretty=oneline -abbrev-commit #更简单--简写的commit-id\r\n		\r\n		#翻页与退出\r\n			#当gitlog日志命令显示的内容太多，无法在一页内显示完毕所有内容时，其最后一行会出现- -个冒号，让输入命令常用的命			令有:回车:显示下一行。空格:显示下一页。q:退出git log命令。\r\n			\r\n         #HEAD指针: Git会默认创建- -个master分支，即主分支。这是Git对版本进行管理的唯- -的一 条时间线。在这条master时间线		 上有很多版本的时间节点，而HEAD指针则指向的是当前刚刚提交的版本时间节点。\r\n         \r\n         #查看可引用历史版本--使用 git log 命令只可以查看到HEAD指针及其之前的版本信息,如果版本发生回退，则可能会出现HEAD指		针之后仍存在版本的情况，而这些版本信息通过git log命令是看不到的。所以我们就得使用git reflog可查看到所有历史版本信		 息。\r\n\r\n		#版本的回退\r\n			#回退到指定版本。但仅仅修改分支中的HEAD指针的位置，不会改变工作区与暂存区中的文件的版本。实现上是改变了暂存区			 commit之前的状态。\r\n			git reset --soft HEAD^    #回退到之前一个版本\r\n			git reset --mixed HEAD^^  #回退到指定版本\r\n			git reset ==hard          #回退到指定版本\r\n#删除文件\r\n#要删除文件，首先要清楚该文件所处的git状态。若要是该文件未被Git管理，在工作区直接进行删除即可。但是，若该文件已经经过多次add与commit操作后要文件要被删除，则我们就需要通过Git命令来操作。\r\n	#删除暂存区指定文件\r\n	git rm --cached filename\r\n	#删除工作区指定文件\r\n	#删除本地库指定文件\r\n```\r\n\r\n\r\n\r\n## git提交忽略文件\r\n\r\n> 一般情况下工作区中的文件都是要交给Git管理的，但有些文件并不想交给Git管理，但是又由于该文件处理工作区，所有我们在执行git status 命令的时候会给出xx文件Untracked (未被跟踪)。\r\n\r\n**解决办法：**\r\n\r\n​	<u>添加要忽略的文件名到.gitignore文件中，那Git就不会再检测该文件</u><u>，将忽略文件中的文件名删除之后，那么查看状态的时候该文件又被提示:未被跟踪。</u>\r\n\r\n1. 我们通过一些设置让 Git 忽略这些文件，再运行git status命令时不对其进行检测\r\n2. 只要在工作区创建一个文件，名称为`.gitignore`\r\n3. 把要被忽略的文件名写入到其中\r\n4. 然后将.gitignore文件add添加并提交commit到本地版本库即可\r\n\r\n**忽略文件编写规则：**\r\n\r\n1. 忽略文件中的空行或以井号(#）开始的行将会被忽略。\r\n2. 可以使用Linux通配符。例如∶星号(*)代表任意多个字符，问号( ﹖)代表一个字符，方括号([abc] )代表可选字符范围，大括号( {string1,string2,…})代表可选的字符串等。\r\n3. 如果名称的最前面有一个感叹号(!)，表示例外规则，将不被忽略。\r\n4. 如果名称的最前面是一个路径分隔符(/ )，表示要忽略的文件在此目录下，而子目录中的文件不忽略。\r\n5. 如果名称的最后面是一个路径分隔符（/ )，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略)。\r\n\r\n```bash\r\n#为注释\r\n*. txt 			#忽略所有. txt结尾的文件\r\n! 1ib. txt		#但1ib. txt除外\r\n/temp			#仅忽略项目根目录下的TOD0文件，不包括其它目录temp\r\nbui1d/			#忽略bui1d/目录下的所有文件\r\ndoc/*. txt		#会忽略doc/notes. txt但不包括doc/server/arch. txt\r\n```\r\n\r\n## SSH密钥绑定GitHub\r\n\r\n1. 注册自己的github账号\r\n\r\n2. 生成本地的SSH公钥，并且绑定到远端的github，实现免密码登录（这一步很重要否则每次提交都需要输入密码）\r\n\r\n   ```bash\r\n   #进入C:\\Users\\yu\'chun\\.ssh目录\r\n   #生成公钥\r\n   ssh-keygen\r\n   ```\r\n\r\n   生成结果![image-20210603163230769](https://i.loli.net/2021/06/03/khQn7tDSZMCbY98.png)\r\n\r\n3. 将密钥添加至github/jitee即可添加成功\r\n\r\n   ![image-20210603190555558.png](https://i.loli.net/2021/06/03/iB6eVhfDrPHOINt.png)\r\n\r\n   \r\n\r\n\r\n\r\n# Git学习笔记04 -- Git分支\r\n\r\n## Git主干\r\n\r\n+ Git是以时间为主线对版本进行管理的，而这条时间主线就是Git主干。\r\n\r\n+ 主干上的每一个节点就是一个版本，即一次commit提交。\r\n\r\n+ 在主干上可以定义多个指针，指向不同的节点。\r\n\r\n+ Git默认会创建一个名称为master的指针\r\n\r\n  默认情况下用户操作的是master指针，但用户通过命令对操作的指针进行切换。用户每次提交一次，就会形成一个新的节点，当前操作的指针就会向前移动一次。\r\n\r\n  ![image-20210604184931188](https://i.loli.net/2021/06/04/TwZlAbBQaRHumzV.png)\r\n\r\n## Git分支\r\n\r\n+ 为了更加形象的描述指针的移动轨迹，我们称某一个指针的移动轨迹为一个分支\r\n\r\n  这样的话，一个指针就代表了一个分支，可以使用不同的指针操作不同的分支。Master指针的移动轨迹与Git的主干是重合，所以称为master主分支。\r\n\r\n+ Git中还有一个特殊的指针叫HEAD\r\n\r\n  代表当前版本。其总是指向当前分支的当前版本，即总是指向当前分支指针所指向的节点（版本）\r\n\r\n  ![image-20210604184945967](https://i.loli.net/2021/06/04/PwuDRxk5Ha7tl2S.png)\r\n\r\n## 分支的合并\r\n\r\n+ 当dev分支上的工作完成后，需要将其合并到主分支master 上\r\n\r\n  合并过程其实很快，只需要将master指针指向dev指针指向的节点，然后再将HEAD指针指向master指针指向的节点即可。即分支的合并就是修改了两个指针的指向而已。\r\n\r\n+ 对于合并的较形象的理解是，合并就是将原来在dev分支上的节点，全部投射到master分支上，即全部合并到master分支上。\r\n\r\n+ 分支合并后的删除\r\n\r\n  1. 合并分支之后会带来两条分支节点个数不相同的问题\r\n\r\n     将dev分支合并到master分支修改的仅仅是master与 HEAD指针，而dev指针并未修改。即仅仅是将dev上的节点投射到master分支上，并未将master分支上的节点投射到dev分支上。所以合并后，dev分支中的节点会少于master分支上的节点，即 dev分支上的文件版本低于master分支的。\r\n\r\n     2.合并后的dev分支不仅无用还会带来版本不一致的麻烦，因此一般需要将dev分支删除\r\n\r\n## 分支基本操作指令\r\n\r\n创建并切换分支\r\n\r\n```bash\r\ngit checkout -b branchName\r\n```\r\n\r\n查看系统的分支\r\n\r\n```bash\r\ngit branch\r\n```\r\n\r\n切换分支\r\n\r\n```bash\r\ngit checkout branchName\r\n```\r\n\r\n删除分支\r\n\r\n```bash\r\n#若要删除某一分支，必须要保证当前分支不能是被删除的分支\r\ngit branch -d branchName\r\n```\r\n\r\n合并分支\r\n\r\n```bash\r\n#对于分支的合并需要注意，如果要将分支B合并到分支A上，首先要将当前分支切换色A分支上，然后再运行合并命令\r\ngit merge branchName\r\n```\r\n\r\n## 分支合并与冲突\r\n\r\n> Git的冲突检测单位是文件，即当不同分支对同一个文件进行修改后进行合并，就会产生冲突。\r\n\r\n冲突将导致 merge 指令失败\r\n\r\n一、解决冲突\r\n\r\n方法就是手工修改文件的冲突内容，然后add添加并commit 提交\r\n\r\n```bash\r\nvim filename\r\n```\r\n\r\n二、查看冲突日志\r\n\r\n```bash\r\ngit log --pretty=oneline --graph  # \r\ngit log --pretty=oneline --graph --abbrev-commit #缩写的commit-id\r\n```\r\n\r\n三、解决冲突并合并成功后删除分支\r\n\r\n```bash\r\n#先切换到master分支后再删除dev分支\r\ngit checkout master\r\ngit branch -d branchName\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 1, 'Git-QuickStart', 0, 1, 2, '2021-10-19 15:53:24', '2021-10-19 15:53:24');
INSERT INTO `blog` VALUES (3, 'Spring+vue+shiro脚手架', '> 该项目已开源在github，[项目代码]()\r\n>\r\n> 数据库文件可在github中获取\r\n\r\n本文旨在快速搭建一个基于Vue2.X+Springboot的前后端分离的项目，使前端界面展示数据库数据\r\n\r\n## 环境与开发工具\r\n\r\n+ Node.js   \r\n+ Jdk 11\r\n+ IDEA--开发工具\r\n+ Springboot    v2.5.5\r\n+ mybatis-plus 3.4.2(对mybatis只做增强不做改变，便于简单查询)\r\n\r\n## Springboot后端接口开发\r\n\r\nIDEA中新建一个Springboot应用，从数据库中查询数据并返回，保证Springboot应用正常运行，即为搭建成功\r\n\r\n**项目结构**\r\n\r\n![image-20211016175042189](https://i.loli.net/2021/10/17/CFnbyQ5sEYf9Jpi.png)\r\n\r\n`pom.xml`相关依赖\r\n\r\n```xml\r\n<dependencies>\r\n        <!--web启动器-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <!--Lombok-->\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n        <!--mysql驱动-->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n        </dependency>\r\n        <!--mybatis-plus-->\r\n        <dependency>\r\n            <groupId>com.baomidou</groupId>\r\n            <artifactId>mybatis-plus-boot-starter</artifactId>\r\n            <version>3.4.2</version>\r\n        </dependency>\r\n    </dependencies>\r\n```\r\n\r\n`Goods`商品实体类\r\n\r\n```\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Data\r\n@TableName(\"goods\")\r\npublic class Goods {\r\n    private int id;\r\n    private String price;\r\n    private String name;\r\n}\r\n\r\n```\r\n\r\n`GoodMapper`\r\n\r\n```java\r\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\r\nimport com.loki.pojo.Goods;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n@Mapper\r\npublic interface GoodMapper extends BaseMapper<Goods> {\r\n}\r\n```\r\n\r\n`GoodService`\r\n\r\n```java\r\nimport com.baomidou.mybatisplus.extension.service.IService;\r\nimport com.loki.pojo.Goods;\r\n\r\npublic interface GoodService extends IService<Goods> {\r\n}\r\n```\r\n\r\n`GoodServiceImpl`\r\n\r\n```java\r\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\r\nimport com.loki.mapper.GoodMapper;\r\nimport com.loki.pojo.Goods;\r\nimport com.loki.service.GoodService;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class GoodServiceImpl extends ServiceImpl<GoodMapper, Goods> implements GoodService {\r\n}\r\n```\r\n\r\n`TestController`\r\n\r\n```java\r\nimport com.loki.pojo.Goods;\r\nimport com.loki.service.GoodService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport java.util.List;\r\n@RestController\r\npublic class TestController {\r\n    @Autowired\r\n    GoodService goodService;\r\n    @RequestMapping(\"/test\")\r\n    public List<Goods> test() {\r\n        return goodService.list();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**访问localhost:9090/test，成功返回一个Json字符串，至此，后端模块开发完成**\r\n\r\n![image-20211016175941480](https://i.loli.net/2021/10/16/NYdAlRcKnxtL61V.png)\r\n\r\n## vue前端界面开发\r\n\r\n### Vue的安装\r\n\r\n> 首先确保本机有Node.js的环境，否则无法通过以下命令行方式安装\r\n\r\n**以管理员身份运行命令行（Win+R 输入cmd），输入以下命令** \r\n\r\n```\r\nnpm install @vue/cli -g  //默认安装Vue3最新版本，这里vue3是兼容vue2的所有东西的\r\n```\r\n\r\n**验证是否安装成功**\r\n\r\n```\r\nvue -V //运行该命令，出现对应版本号，则安装成功\r\n```\r\n\r\n![](https://i.loli.net/2021/10/16/WJONQ9jTiAywo6H.png)\r\n\r\n### 创建一个Vue项目\r\n\r\n> vue ui是@vue/cli3.0增加一个可视化项目管理工具，可以运行项目、打包项目，检查等操作。对于初学者来说，可以少记一些命令\r\n\r\n新建一个文件夹，在该文件夹下执行\r\n\r\n```bash\r\nvue ui\r\n```\r\n\r\n![image-20211017183456775](https://i.loli.net/2021/10/17/JIAQPNES9XCgfnL.png)\r\n\r\n![](https://s3.bmp.ovh/imgs/2021/10/e28997f6eadff11f.png)\r\n\r\n点击创建新项目\r\n\r\n![image-20211017183918155](https://i.loli.net/2021/10/17/BFxw4JCX8rnkled.png)\r\n\r\n点击下一步，**选择手动配置项目**\r\n\r\n![](https://s3.bmp.ovh/imgs/2021/10/0da42d2592da2976.png)\r\n\r\n勾选红框内的选项卡，点击下一步，**选择Vue版本为2.x**\r\n\r\n![image-20211017184232510](https://i.loli.net/2021/10/17/RaoBkfc38zrliA1.png)\r\n\r\n选择创建项目，但不保存预设，至此，一个干净的Vue项目就生成了\r\n\r\n在项目跟目录下运行，并访问端口，测试是否创建成功\r\n\r\n```\r\nnpm run serve\r\n```\r\n\r\n至此，所有依赖加载完毕，我们可以来写代码了\r\n\r\n\r\n\r\n\r\n\r\n### 准备工作\r\n\r\n创建项目成功后，我们使用idea工具来进行开发，使用idea打开项目的根目录文件夹\r\n\r\nidea需要安装第三方插件所以来编辑我们的vue程序，因此，我们需要一个插件 `vue.js`,去插件市场安装即可\r\n\r\n![image-20211017185010942](https://i.loli.net/2021/10/17/C9nz763dWu8GyLs.png)\r\n\r\n**idea自带命令行终端**，操作方式与命令行相同\r\n\r\n![](https://s3.bmp.ovh/imgs/2021/10/a8303c10dd4c3c6b.png)\r\n\r\n### 安装Element UI\r\n\r\n1、**切换到项目根目录**，使用npm安装element-ui依赖\r\n\r\n```\r\nnpm install element-ui \r\n```\r\n\r\n![image-20211017190022386](https://i.loli.net/2021/10/17/BNbUeiWRkcHxzdr.png)\r\n\r\n2、在项目src目录下的`main.js`，引入element-ui依赖\r\n\r\n```\r\nimport Element from \'element-ui\'\r\nimport \"element-ui/lib/theme-chalk/index.css\"\r\nVue.use(Element)\r\n```\r\n\r\n### 安装Axios\r\n\r\n> Axios是一个基于 promise 的 HTTP 库，这样我们进行前后端对接的时候，使用这个工具可以提高我们的开发效率\r\n\r\n\r\n\r\n1、**切换到项目根目录**，使用npm安装Axios依赖\r\n\r\n```\r\nnpm install axios\r\n```\r\n\r\n2、在项目src目录下的`main.js`，引入element-ui依赖\r\n\r\n```\r\nimport axios from \'axios\'\r\nVue.prototype.$axios = axios \r\n```\r\n\r\n`Vue.prototype.$axios = axios `\r\n\r\n**这行代码在main.js里面将axios 挂载到了vue的原型上，相当于一次全局安装，需要使用的时候直接this.$axios就行\r\n\r\n至此，所有前端环境准备完成，我们开始编写代码\r\n\r\n**项目结构**\r\n\r\n![image-20211017232137792](https://i.loli.net/2021/10/17/napFwjMt9GlEcUr.png)\r\n\r\n`router/index.js`\r\n\r\n```js\r\nimport Vue from \'vue\'\r\nimport VueRouter from \'vue-router\'\r\n\r\nVue.use(VueRouter)\r\n\r\nconst routes = [\r\n  {\r\n    path:\'/\',\r\n    component:()=>import(\'../views/Goods\')\r\n  }\r\n]\r\n\r\nconst router = new VueRouter({\r\n  mode: \'history\',\r\n  base: process.env.BASE_URL,\r\n  routes\r\n})\r\n\r\nexport default router\r\n```\r\n\r\n`views/Goods.view`\r\n\r\n```vue\r\n<template>\r\n    <div>\r\n        <template>\r\n            <el-table\r\n                    :data=\"tableData\"\r\n                    border\r\n                    style=\"width: 100%\">\r\n                <el-table-column\r\n                        prop=\"id\"\r\n                        label=\"编号\"\r\n                        width=\"180\">\r\n                </el-table-column>\r\n                <el-table-column\r\n                        prop=\"name\"\r\n                        label=\"姓名\"\r\n                        width=\"180\">\r\n                </el-table-column>\r\n                <el-table-column\r\n                        prop=\"price\"\r\n                        label=\"价格\">\r\n                </el-table-column>\r\n            </el-table>\r\n        </template>\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                tableData: [{/*测试数据*/\r\n                    id: \'2016-05-03\',\r\n                    name: \'王小虎\',\r\n                    price: \'上海市普陀区金沙江路 1518 弄\'\r\n                }]\r\n            }\r\n        },\r\n        created() {/*界面初始化操作，界面加载之前执行*/\r\n            const _this = this/*该this是vue全局的this，防止了函数中写this是方法的this*/\r\n            this.$axios.get(\'http://localhost:8090/test\').then(function (resp) {\r\n                _this.tableData = resp.data;\r\n\r\n            })\r\n        }\r\n    }\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n`App.vue`\r\n\r\n```\r\n<template>\r\n  <div id=\"app\">\r\n    <router-view/>\r\n  </div>\r\n</template>\r\n\r\n<style>\r\n\r\n</style>\r\n```\r\n\r\n`main.js`\r\n\r\n```\r\nimport Vue from \'vue\'\r\nimport App from \'./App.vue\'\r\nimport router from \'./router\'\r\nimport store from \'./store\'\r\n/*引入element-UI的依赖*/\r\nimport Element from \'element-ui\'\r\nimport \"element-ui/lib/theme-chalk/index.css\"\r\n/*引入axios*/\r\nimport axios from \'axios\'\r\n\r\n/*全局使用*/\r\nVue.use(Element)\r\nVue.prototype.$axios = axios\r\n\r\nVue.config.productionTip = false\r\n\r\nnew Vue({\r\n  router,\r\n  store,\r\n  render: h => h(App)\r\n}).$mount(\'#app\')\r\n```\r\n\r\n\r\n\r\n## 解决访问后端数据时产生的跨域问题\r\n\r\n Java中新建config包，编写`CorsConfig`类\r\n\r\n```\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.cors.CorsConfiguration;\r\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\r\nimport org.springframework.web.filter.CorsFilter;\r\n\r\n@Configuration\r\npublic class CorsConfig {\r\n    private CorsConfiguration buildConfig() {\r\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\r\n        corsConfiguration.addAllowedOrigin(\"*\"); // 1允许任何域名使用\r\n        corsConfiguration.addAllowedHeader(\"*\"); // 2允许任何头\r\n        corsConfiguration.addAllowedMethod(\"*\"); // 3允许任何方法（post、get等）\r\n        return corsConfiguration;\r\n    }\r\n\r\n    @Bean\r\n    public CorsFilter corsFilter() {\r\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\r\n        source.registerCorsConfiguration(\"/**\", buildConfig()); // 4\r\n        return new CorsFilter(source);\r\n    }\r\n}\r\n```\r\n\r\n## 运行结果\r\n\r\n运行前端界面，可以看到从数据库中查到了数据并返回到\r\n\r\n![image-20211017232537681](https://i.loli.net/2021/10/17/GYN6QBCTcUIkasp.png)\r\n\r\n\r\n\r\n', 0, '本文旨在快速搭建一个基于Vue2.X+Springboot的前后端分离的项目，使前端界面展示数据库数据', 0, 2, 2, '2021-10-19 15:53:24', '2021-10-19 15:53:24');
INSERT INTO `blog` VALUES (4, 'Springboot学习笔记', '---\r\nStartTime: 2021-9-21\r\nEndTime: 2021-10-\r\n\r\n---\r\n\r\n\r\n\r\n# SpringBoot学习笔记\r\n\r\n## 回顾Spring\r\n\r\n+ Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  \r\n\r\n+ Spring是为了解决企业级应用开发的复杂性而创建的，简化开发\r\n\r\n## SpringBoot简介\r\n\r\n+ Spring Boot 基于 Spring 开发\r\n+ Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。\r\n+ Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。\r\n+ 同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用\r\n+ 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像Maven整合了所有的jar包，spring boot整合了所有的框架\r\n+ [官方api文档](https://docs.spring.io/spring-boot/)\r\n\r\n## 微服务\r\n\r\n`James Lewis` 和 `Martin Fowler` 提出微服务完整概念\r\n\r\nhttps://martinfowler.com/microservices/\r\n\r\n> In short, the **microservice architectural style** is an approach to developing a single application as a **suite of small services**, each **running in its own process** and communicating with **lightweight** mechanisms, often an **HTTP** resource API. These services are **built around business capabilities** and **independently deployable** by fully **automated deployment** machinery. There is a **bare minimum of centralized management** of these services, which may be **written in different programming languages** and use different data storage technologies.-- [James Lewis and Martin Fowler (2014)](https://martinfowler.com/articles/microservices.html)\r\n\r\n- 微服务是一种架构风格\r\n- 一个应用拆分为一组小型服务\r\n\r\n- 每个服务运行在自己的进程内，也就是可独立部署和升级\r\n- 服务之间使用轻量级HTTP交互\r\n\r\n- 服务围绕业务功能拆分\r\n- 可以由全自动部署机制独立部署\r\n\r\n- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术\r\n\r\n## 第一个SpringBoot程序\r\n\r\n### 项目创建\r\n\r\n+ 使用 IDEA 直接创建项目--`Spring Initializr`\r\n  + New Project\r\n  + 选择spring initalizr，可以看到默认就是去官网的快速构建工具那里实现\r\n  + 填写项目信息\r\n  + 选择需要初始化的组件（初学勾选 Web 即可）\r\n    + 这一步相当于自动在pom.xml中加入依赖，项目创建成功后添加也可以\r\n  + 填写项目路径\r\n\r\n### 项目结构\r\n\r\n \r\n\r\n![image-20210921180503563](https://i.loli.net/2021/09/21/wnVG2WOMslq1hif.png)\r\n\r\n## 底层原理\r\n\r\n### 自动配置\r\n\r\n![image-20210923010006414](D:\\桌面\\P_picture_cahe\\image-20210923010006414.png)\r\n\r\n了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效，因此，应该知道一个spring底层注解：@Conditional\r\n\r\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效\r\n\r\n![image-20210923010453918](https://i.loli.net/2021/09/23/ZwfgQS9Hp7u1KBP.png)\r\n\r\n那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了，怎么知道哪些自动配置类生效？\r\n\r\n**我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；**\r\n\r\n```yaml\r\n#开启springboot的调试类\r\ndebug=true\r\n```\r\n\r\n### 为什么引入依赖不需要指定版本\r\n\r\n**Springboot自动版本仲裁机制**\r\n\r\n在pom.xml中找到父工程\r\n\r\n+ spring-boot-dependencies: 核心依赖在父工程中\r\n\r\n+ 我们在引入一些依赖的时候不需要指定版本，就是因为有这些版本仓库\r\n\r\n  ![image-20210921181432494](https://i.loli.net/2021/09/21/7NXSoabQOqYvWkK.png)\r\n\r\n### 启动器\r\n\r\n```xml\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-web</artifactId>\r\n</dependency>\r\n```\r\n\r\n+ 我们需要什么功能，只需要找到对应的启动器就可以了\r\n+ 比如spring-boot-starter-web，他就会帮我们自动导入web环境所有的依赖!\r\n\r\n\r\n\r\n### 主程序\r\n\r\n```java\r\n//标注这个类是一个Springboot的应用\r\n@SpringBootApplication\r\n//只要添加这个注解即可，所以这个类名是可以修改的\r\npublic class Springboot01HelloApplication {\r\n    public static void main(String[] args) {\r\n        //启动Springboot应用\r\n        SpringApplication.run(Springboot01HelloApplication.class, args);\r\n    }\r\n}\r\n```\r\n\r\n+ 分析注解\r\n\r\n  `@SpringBootConfiguration`\r\n\r\n  ​	@Configuration : Spring配置类\r\n\r\n  ​	@Component ： 说明这是一个Spring的组件\r\n\r\n  `@EnableAutoConfiguration`自动配置\r\n\r\n  ​	@AutoConfigurationPackage : 自动配置包\r\n\r\n  ​		@Import(AutoConfigurationImportSelector.class) ：自动配置‘包注册’\r\n\r\n  ​	@Import(AutoConfigurationImportSelector.class) ：自动配置导入选择\r\n\r\n![image-20210921190848023](https://i.loli.net/2021/09/21/IBwTOSyViXnQN54.png)\r\n\r\n> 自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中\r\n\r\n**结论：**\r\n\r\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\r\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\r\n3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\r\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\r\n5. 有了自动配置类,免去了我们手动编写配置注入功能组件等的工作；\r\n\r\n### **SpringApplication.run分析**\r\n\r\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\r\n\r\n`SpringApplication`\r\n\r\n**这个类主要做了以下四件事情：**\r\n\r\n1、推断应用的类型是普通的项目还是Web项目\r\n\r\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\r\n\r\n3、找出所有的应用程序监听器，设置到listeners属性中\r\n\r\n4、推断并设置main方法的定义类，找到运行的主类\r\n\r\n`run方法`\r\n\r\n+ 关于Springboot谈谈自己的理解\r\n\r\n  首先将自动装配的过程分析一下，关于run方法并不需要了解太多，除非你想重构一个springboot\r\n\r\n## Starter\r\n\r\n\r\n\r\n## 配置文件\r\n\r\n> SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.yaml\r\n\r\n### yaml语法\r\n\r\nYAML仍是一种标记语言\r\n\r\n+ **基础语法**\r\n\r\n  说明：语法要求严格！\r\n\r\n  1、空格不能省略\r\n\r\n  2、以缩进来控制层级关系，**只要是左边对齐的一列数据都是同一个层级的**\r\n\r\n  3、属性和值的大小写都是十分敏感的。\r\n\r\n```yaml\r\n#普通的 key-value\r\nname: oliverloki\r\n#对象\r\nstudent:\r\n	name: loki\r\n	age: 20\r\n#行内写法\r\nstudent: {name:loki,age:3}\r\n#数组\r\npet:\r\n	- cat\r\n	- dog\r\n	- pig\r\npet: [cat,dog,pig]\r\n```\r\n\r\n+ yaml可以注入到配置类中\r\n\r\n  `@ConfigurationProperties`\r\n\r\n  作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 `prefix = “person”` , 将配置文件中的person下面的所有属性一一对应\r\n\r\n  ```java\r\n  @Component //注册bean\r\n  \r\n  @ConfigurationProperties(prefix = \"person\")\r\n  \r\n  public class Person {  \r\n  	...\r\n  }\r\n  ```\r\n\r\n### Springboot配置文件加载的位置\r\n\r\n**请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面**\r\n\r\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\r\n\r\n优先级1：项目路径下的config文件夹配置文件\r\n\r\n优先级2：项目路径下配置文件\r\n\r\n优先级3：资源路径下的config文件夹配置文件\r\n\r\n优先级4：资源路径下配置文件\r\n\r\n## JSR303校验\r\n\r\nSpringboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；\r\n\r\n```java\r\n@Component //注册bean\r\n@ConfigurationProperties(prefix = \"person\")\r\n@Validated  //数据校验\r\npublic class Person {\r\n\r\n    @Email(message=\"邮箱格式错误\") //name必须是邮箱格式\r\n    private String name;\r\n}\r\n```\r\n\r\n### 常用参数\r\n\r\n```java\r\n@NotNull(message=\"名字不能为空\")\r\nprivate String userName;\r\n@Max(value=120,message=\"年龄最大不能查过120\")\r\nprivate int age;\r\n@Email(message=\"邮箱格式错误\")\r\nprivate String email;\r\n\r\n空检查\r\n@Null       验证对象是否为null\r\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\r\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\r\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\r\n    \r\nBooelan检查\r\n@AssertTrue     验证 Boolean 对象是否为 true  \r\n@AssertFalse    验证 Boolean 对象是否为 false  \r\n    \r\n长度检查\r\n@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  \r\n@Length(min=, max=) string is between min and max included.\r\n\r\n日期检查\r\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前  \r\n@Future     验证 Date 和 Calendar 对象是否在当前时间之后  \r\n@Pattern    验证 String 对象是否符合正则表达式的规则\r\n\r\n.......等等\r\n除此以外，我们还可以自定义一些数据校验规则\r\n```\r\n\r\n## 多环境切换\r\n\r\n我们在主配置文件编写的时候，文件名可以是 `application-{profile}.properties/yml` , 用来指定多个环境版本\r\n\r\n**例如：**\r\n\r\n**application-test.properties 代表测试环境配置**\r\n\r\n**application-dev.properties 代表开发环境配置**\r\n\r\n但是Springboot并不会直接启动这些配置文件，它**默认使用application.properties主配置文件**；\r\n\r\n我们需要通过一个配置来选择需要激活的环境：\r\n\r\n```\r\n#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；\r\n#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；\r\nspring.profiles.active=dev\r\n```\r\n\r\n> 多环境的情况下，yaml格式的配置文档比起properties有很多优势\r\n\r\n```yaml\r\nserver:\r\n  port: 8081\r\n#选择要激活那个环境块\r\nspring:\r\n  profiles:\r\n    active: prod\r\n    \r\n---\r\nserver:\r\n  port: 8083\r\nspring:\r\n  profiles: dev #配置环境的名称\r\n---\r\n\r\nserver:\r\n  port: 8084\r\nspring:\r\n  profiles: prod  #配置环境的名称\r\n```\r\n\r\n## SpringbootWeb开发\r\n\r\n+ 静态资源映射规则\r\n+ 欢迎页的映射\r\n+ 从jsp到模板引擎Thymeleaf\r\n+ 拓展与装配SpringMVC\r\n+ 增删改查\r\n+ 拦截器\r\n+ 国际化（中英文切换）\r\n\r\n### 静态资源映射规则\r\n\r\n> SpringBoot中，SpringMVC的web配置都在 `WebMvcAutoConfiguration` 这个配置类里面\r\n\r\n该类中有一个`addResourceHandlers`方法，该方法决定了静态资源映射的两种方式\r\n\r\n+ webjars\r\n\r\n  + Webjars本质就是以jar包的方式引入我们的静态资源，我们以前要导入一个静态资源文件，直接导入即可\r\n\r\n  + 使用SpringBoot需要使用Webjars，我们可以去搜索一下：网站：https://www.webjars.org \r\n\r\n    ![image-20210923153723919](D:\\桌面\\P_picture_cahe\\image-20210923153723919.png)\r\n\r\n  + 所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源\r\n\r\n+ **导入自己的静态资源，该遵循什么样的规则呢**\r\n\r\n  + `CLASSPATH_RESOURCE_LOCATIONS`,全局搜索这个变量，它代表和静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容\r\n\r\n    **所以得出结论，以下四个目录存放的静态资源可以被我们识别**\r\n\r\n    ```java\r\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \r\n        \"classpath:/META-INF/resources/\",\r\n    	\"classpath:/resources/\",\r\n        \"classpath:/static/\", \r\n        \"classpath:/public/\" };\r\n    ```\r\n\r\n\r\n\r\n> 2.1.7版本的addResourceHandlers方法，每个版本不尽相同\r\n\r\n```java\r\n@Override\r\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n    if (!this.resourceProperties.isAddMappings()) {\r\n        // 已禁用默认资源处理\r\n        logger.debug(\"Default resource handling disabled\");\r\n        return;\r\n    }\r\n    // 缓存控制\r\n    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\r\n    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\r\n    // webjars 配置\r\n    if (!registry.hasMappingForPattern(\"/webjars/**\")) {\r\n        customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\")\r\n                                             .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\r\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\r\n    }\r\n    // 静态资源配置\r\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\r\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\r\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\r\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\r\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\r\n    }\r\n}\r\n```\r\n\r\n### 欢迎页的映射\r\n\r\n在`WebMvcAutoConfiguration`中，看到获取欢迎页的源码\r\n\r\n```java\r\n@Bean\r\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\r\n                                                           FormattingConversionService mvcConversionService,\r\n                                                           ResourceUrlProvider mvcResourceUrlProvider) {\r\n    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(\r\n        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页\r\n        this.mvcProperties.getStaticPathPattern());\r\n    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\r\n    return welcomePageHandlerMapping;\r\n}\r\n```\r\n\r\n结论：欢迎页-----静态资源文件夹下的所有 index.html 页面；被 /** 映射\r\n\r\n### 模板引擎Thymeleaf\r\n\r\n**使用方法**\r\n\r\n在html中导入命名空间，在html编写符合规则的代码即可\r\n\r\n```\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n```\r\n\r\n**关闭Thymeleaf可以解决静态资源更新不及时的问题**\r\n\r\n```\r\n#关闭模板引擎缓存\r\nspring:\r\n  thymeleaf:\r\n    cache: false\r\n```\r\n\r\n[Thymeleaf语法]()\r\n\r\n### 拓展与装配SpringMVC\r\n\r\n[MVC自动配置官方文档（Spring MVC Auto-configuration）](https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration)\r\n\r\n> SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的\r\n\r\n如果你想保留Spring Boot MVC特性，并且想添加额外的MVC配置(拦截器、格式化器、视图控制器和其他特性)，可以**定义一个WebMvcConfigurer类型带@Configuration的类**，但不需要@EnableWebMvc。\r\n\r\n```java\r\n//应为类型要求为WebMvcConfigurer，所以我们实现其接口\r\n//可以使用自定义类扩展MVC的功能\r\n@Configuration\r\n/*\r\n@EnableWebMvc \r\n全面接管视图解析器-即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置，不推荐使用全面接管SpringMVC\r\n*/\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        // 浏览器发送/test ， 就会跳转到test页面；\r\n        registry.addViewController(\"/test\").setViewName(\"test\");\r\n    }\r\n}\r\n```\r\n\r\n**对@EnableWebMvc 注解的底层解析**\r\n\r\n容器中不存在这个类时，自动配置类才会生效\r\n\r\n![image-20210924163701519](https://i.loli.net/2021/09/24/qrwAKkisLovn8fO.png)\r\n\r\n@EnableWebMvc生成WebMvcConfigurationSupport类，进而使得MVC完全失效\r\n\r\n![image-20210924163844290](https://i.loli.net/2021/09/24/nu49osyfV3HltGY.png)\r\n\r\n### 页面国际化\r\n\r\n1. 在resources资源文件下新建一个i18n目录，存放国际化配置文件\r\n2. 新建`login.properties`、`login_zh_CN.properties`==>IDEA自动识别了我们要做国际化操作\r\n\r\n![image-20210927214840111](https://i.loli.net/2021/09/27/Avl28Q9HqKbYB1G.png)\r\n\r\n**idea支持配置文件可视化编程**\r\n\r\n![image-20210927215234873](D:\\桌面\\P_picture_cahe\\image-20210927215234873.png)\r\n\r\n3.国际化文件夹要在这里配置\r\n\r\n```\r\n#关闭模板引擎缓存\r\nspring:\r\n  #国际化配置\r\n  messages:\r\n    basename: i18n.login,i18n.leftbar\r\n```\r\n\r\n**实现**\r\n\r\n通过继承`LocaleResolver`并重写``resolveLocale`方法实现**根据按钮自动切换中文英文**\r\n\r\n```java\r\nimport org.springframework.web.servlet.LocaleResolver;\r\nimport org.thymeleaf.util.StringUtils;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.util.Locale;\r\npublic class MyLocaleResolver implements LocaleResolver {\r\n    @Override\r\n    public Locale resolveLocale(HttpServletRequest request) {\r\n        //获取请求中的语言参数 获取 l\r\n        String language = request.getParameter(\"l\");\r\n        Locale locale = Locale.getDefault();//如果没有参数就使用默认的\r\n\r\n        if (!StringUtils.isEmpty(language)) {//判断locale是否为空\r\n            //zh_CN  国家_地区\r\n            /*\r\n             public Locale(String language, String country) {\r\n                     this(language, country, \"\");\r\n                }\r\n             */\r\n            String[] split = language.split(\"_\");\r\n            locale = new Locale(split[0], split[1]);\r\n        }\r\n        return locale;\r\n    }\r\n    @Override\r\n    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {\r\n    }\r\n}\r\n\r\n```\r\n\r\n配置组件，在自定义MvcConofig下添加bean\r\n\r\n```java\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.LocaleResolver;\r\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\r\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\r\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\r\n\r\n@Configuration\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    //注册自定义国际化组件\r\n    @Bean\r\n    public LocaleResolver localeResolver(){\r\n        return new MyLocaleResolver();\r\n    }\r\n}\r\n\r\n```\r\n\r\n 修改前端页面的跳转链接\r\n\r\n```html\r\nThymeleaf传参使用括号\r\n<a class=\"btn btn-sm\" th:href=\"@{/index.html(l=\'zh_CN\')}\">中文</a>\r\n<a class=\"btn btn-sm\" th:href=\"@{/index.html(l=\'en_US\')}\">English</a>\r\n```\r\n\r\n### 登录拦截器\r\n\r\n+ 拦截器要继承`HandlerInterceptor`接口，并重写`preHandle`方法\r\n+ 写好之后的拦截器要在自定义视图解析器中注入到IoC容器\r\n\r\n```java\r\nimport org.springframework.web.servlet.HandlerInterceptor;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n//登录拦截器，通过判断session来实现\r\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        //通过判断用户session是否存在来确定是否登录\r\n        if (request.getSession().getAttribute(\"loginuser\")==null){//session为空\r\n            request.setAttribute(\"msg\",\"请登录后访问该界面\");\r\n            request.getRequestDispatcher(\"/index.html\").forward(request,response);\r\n            return false;//不放行\r\n        }else\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@Configuration\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    //注册拦截器\r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\")\r\n                .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\",\"/js/**\",\"/css/**\",\"/img/**\");\r\n    }\r\n}\r\n```\r\n\r\n### 设置网站Favicon\r\n\r\n\r\n\r\nSpring Boot不同版本对Favicon的支持\r\n\r\n在早些版本中Spring Boot对Favicon进行了默认支持，并且通过如下配置进行关闭操作：\r\n\r\n```yaml\r\nspring.mvc.favicon.enabled=false ## 关闭\r\n```\r\n\r\n在Spring Boot2.2.x中，将默认的favicon.ico移除，同时也不再提供上述application.properties中的属性配置\r\n\r\n因此，可以使用自定义Favicon\r\n\r\n**自定义Favicon** \r\n\r\n正常情况下，直接将命名为favicon.ico的网站图标放在resources或static目录即可显示，但如果使用的版本无法显示。\r\n\r\n首先排除浏览器缓存的问题。在撰写本文时多次遇到浏览器缓存导致无法展示的情况。一般操作步骤，清除浏览器缓存，重启浏览器，即可展示。\r\n\r\n同时，如果需要在页面中通过代码进行引入。下面展示使用Thymeleaf时的引入方式：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\"/>\r\n    <title>Hello Favicon</title>\r\n    <link rel=\"icon\" th:href=\"@{/favicon.ico}\" type=\"image/x-icon\"/>\r\n    <link rel=\"bookmark\" th:href=\"@{/favicon.ico}\" type=\"image/x-icon\"/>\r\n</head>\r\n<body>\r\n	<h1>Hello Favicon!</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n### Thymeleaf对公共界面的提取\r\n\r\n**对被提取的元素(组件)**\r\n\r\n页面导航栏等\r\n\r\n```html\r\n<div th:fragment=\"属性值\">\r\n```\r\n\r\n**对被插入的元素**\r\n\r\n```html\r\n<div th:replace=\"~{xxx.html的路径::属性值}\">\r\n```\r\n\r\n**像组件中的元素传值**\r\n\r\n比如判断当前在哪个页面让导航栏高亮\r\n\r\n```html\r\n<div th:replace=\"~{common/xxx.html::属性值(属性名2=\"属性值2\")}\">\r\n```\r\n\r\n**组件判断参数进行一些操作**\r\n\r\n```html\r\n<!--如果属性值a1等于属性值2，说明在属性二的界面，于是三元表达式给a的class属性赋值，这个a标签高亮-->\r\n	<a th:class=\"${属性值a1==\'属性值2\'?\'topnav\':\'topnav active\'}\" > \r\n    <a th:class=\"${属性值a2==\'属性值3\'?\'leftnav\':\'leftnav active\'}\" >    \r\n```\r\n\r\n\r\n\r\n## Springboot持久层\r\n\r\n### 整合Druid\r\n\r\n**Druid简介**\r\n\r\n+ Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。\r\n\r\n+ Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。\r\n\r\n+ Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\r\n\r\n+ Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 `Hikari` 与 `Driud` 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。\r\n\r\n+ Github地址：https://github.com/alibaba/druid/\r\n\r\n**Springboot添加Druid依赖**\r\n\r\ndruid别名德鲁伊\r\n\r\n```xmL\r\n<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\r\n<dependency>\r\n    <groupId>com.alibaba</groupId>\r\n    <artifactId>druid</artifactId>\r\n    <version>1.2.6</version>\r\n</dependency>\r\n```\r\n\r\n**Druid常见问题（github官方版）**\r\n\r\nhttps://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\r\n\r\n**配置Druid**\r\n\r\n数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码\r\n\r\n```yaml\r\nspring:\r\n  datasource:\r\n    username: root\r\n    password: 123456\r\n    #?serverTimezone=UTC解决时区的报错\r\n    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n\r\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\r\n    #druid 数据源专有配置\r\n    initialSize: 5\r\n    minIdle: 5\r\n    maxActive: 20\r\n    maxWait: 60000\r\n    timeBetweenEvictionRunsMillis: 60000\r\n    minEvictableIdleTimeMillis: 300000\r\n    validationQuery: SELECT 1 FROM DUAL\r\n    testWhileIdle: true\r\n    testOnBorrow: false\r\n    testOnReturn: false\r\n    poolPreparedStatements: true\r\n\r\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\r\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\r\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\r\n    filters: stat,wall,log4j\r\n    maxPoolPreparedStatementPerConnectionSize: 20\r\n    useGlobalDataSourceStat: true\r\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\r\n```\r\n\r\n这一步要导入Log4j的依赖\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/log4j/log4j -->\r\n<dependency>\r\n    <groupId>log4j</groupId>\r\n    <artifactId>log4j</artifactId>\r\n    <version>1.2.17</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n### 整合Mybatis plus\r\n\r\n**简介**\r\n\r\n\r\n\r\n**pom.xml中导入mybatis-plus依赖**\r\n\r\n```xml\r\n<dependency>\r\n	<groupId>com.baomidou</groupId>\r\n	<artifactId>mybatis-plus-boot-starter</artifactId>\r\n	<version>3.4.2</version>\r\n</dependency>\r\n```\r\n\r\n**配置application.yaml**\r\n\r\n```yaml\r\nmybatis-plus:\r\n  type-aliases-package: com.loki.pojo\r\n  mapper-locations: classpath:mapper/*.xml\r\n```\r\n\r\n**使用Mybatis-plus做一个简单的查询demo**\r\n\r\n1、com.loki.mapper.UserMapper\r\n\r\n```\r\npublic interface BookMapper extends BaseMapper<Books> {\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**一些注意事项**\r\n\r\n> 解决使用mybatis-plus时，生成的SQL大写变小写加下划线\r\n\r\n**在application.yaml加上以下配置**\r\n\r\n```yaml\r\nmybatis-plus:\r\n  configuration:\r\n    map-underscore-to-camel-case: false\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## BUG\r\n\r\n### springboot新增静态资源无法访问\r\n\r\n解决方法：执行idea右侧maven clean 命令\r\n\r\n### \r\n\r\n\r\n\r\n## 开发小技巧\r\n\r\n### Lombok\r\n\r\n引入lombok Maven依赖\r\n\r\n```xml\r\n		<!--lombok依赖-->\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n```\r\n\r\n```java\r\n@Data //提供该类所有属性的getter/setter方法，还提供了equals、canEqual、hashCode、toString方法\r\n@AllArgsConstructor //提供有参构造\r\n@NoArgsConstructor //提供无参构造\r\n@Slf4j //提供日志打印\r\npublic class Books {\r\n    private int bookId;\r\n    private String bookName;\r\n    private int bookCounts;\r\n    private String detail;\r\n\r\n    public void testLog(){\r\n        //lombok插件的@slf4j提供的功能\r\n        log.info(\"进入到这个方法了\");\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n### Dev tools热部署\r\n\r\n```xml\r\n	<!--Devtools-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-devtools</artifactId>\r\n            <version>2.5.2</version>\r\n        </dependency>\r\n```\r\n\r\n导入后Ctrl+F9===>重新启动\r\n\r\n这个重启做不到真正意义上的热部署，`JRebel`可以实现这个功能，但是是收费的\r\n\r\n\r\n\r\n', 0, 'Springboot从0接近1', 0, 2, 2, '2021-10-19 15:53:24', NULL);
INSERT INTO `blog` VALUES (5, '测试分页用', '# test', 0, '测试', NULL, NULL, 2, NULL, NULL);
INSERT INTO `blog` VALUES (6, '测试分页用', '# test', 0, '测试', NULL, NULL, 2, NULL, NULL);
INSERT INTO `blog` VALUES (7, '测试其他作者', '# test', 0, '测试', NULL, NULL, 3, '2021-10-19 15:53:24', NULL);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comm_id` int NOT NULL,
  `comm_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `comm_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `gmt_create` datetime NULL DEFAULT NULL,
  `blog_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`comm_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, '皮克桃', '很好学到了', NULL, 1);
INSERT INTO `comment` VALUES (2, '唐老鸭', '很好的一篇文章', NULL, 2);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `tag_id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`tag_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------

-- ----------------------------
-- Table structure for tag_blog
-- ----------------------------
DROP TABLE IF EXISTS `tag_blog`;
CREATE TABLE `tag_blog`  (
  `tag_id` int NOT NULL,
  `blog_id` int NOT NULL,
  PRIMARY KEY (`tag_id`, `blog_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag_blog
-- ----------------------------

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `type_id` int NOT NULL AUTO_INCREMENT,
  `type_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`type_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, 'Java');
INSERT INTO `type` VALUES (2, 'Spring');
INSERT INTO `type` VALUES (3, '数据库');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int NOT NULL AUTO_INCREMENT,
  `role` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `github` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', 'admin', 'E10ADC3949BA59ABBE56E057F20F883E', 'test@email', 'null', 'https://ftp.bmp.ovh/imgs/2020/05/9d0208ecdad7fd07.jpg');
INSERT INTO `user` VALUES (2, NULL, 'loki', 'AFDEC7005CC9F14302CD0474FD0F3C96', 'loki@gmail.com', 'https://github.com/OliverLoki', 'https://s3.bmp.ovh/imgs/2021/10/33487a1d8d0cdc7c.jpg');
INSERT INTO `user` VALUES (3, NULL, '测试用户', 'AFDEC7005CC9F14302CD0474FD0F3C96', 'test@qq.com', NULL, 'https://s3.bmp.ovh/imgs/2021/10/33487a1d8d0cdc7c.jpg');

SET FOREIGN_KEY_CHECKS = 1;
